/*
 *  The contents of this file are subject to the Initial
 *  Developer's Public License Version 1.0 (the "License");
 *  you may not use this file except in compliance with the
 *  License. You may obtain a copy of the License at
 *  http://www.ibphoenix.com/main.nfs?a=ibphoenix&page=ibp_idpl.
 *
 *  Software distributed under the License is distributed AS IS,
 *  WITHOUT WARRANTY OF ANY KIND, either express or implied.
 *  See the License for the specific language governing rights
 *  and limitations under the License.
 *
 *  The Original Code was created by Adriano dos Santos Fernandes.
 *
 *  Copyright (c) 2014 Adriano dos Santos Fernandes <adrianosf at gmail.com>
 *  and all contributors signed below.
 *
 *  All Rights Reserved.
 *  Contributor(s): ______________________________________.
 */

#include "Generator.h"
#include "Expr.h"
#include <algorithm>
#include <cctype>
#include <deque>
#include <set>
#include <stdexcept>
#include <string>
#include <vector>

using std::deque;
using std::runtime_error;
using std::set;
using std::string;
using std::transform;
using std::vector;


//--------------------------------------


const char* const Generator::AUTOGEN_MSG =
	"This file was autogenerated by cloop - Cross Language Object Oriented Programming";


//--------------------------------------


static const char* tabs = "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t";

void identify(FILE* out, unsigned ident)
{
	fprintf(out, "%.*s", ident, tabs);
}

static string snakeUpperCase(const string& name)
{
	string result;
	const size_t len = name.length();
	bool wasUpper = true;

	for (size_t i = 0; i < len; ++i)
	{
		const unsigned char c = static_cast<unsigned char>(name[i]);
		const bool isUpper = std::isupper(c) != 0;

		if (isUpper && !wasUpper)
			result += '_';

		result += static_cast<char>(std::toupper(c));
		wasUpper = isUpper;
	}

	return result;
}

static deque<Method*> collectInterfaceMethods(const Interface* interface)
{
	deque<Method*> methods;

	for (const Interface* p = interface; p; p = p->super)
	{
		vector<Method*> block;
		block.reserve(p->methods.size());

		for (const auto& method : p->methods)
			block.push_back(method.get());

		methods.insert(methods.begin(), block.begin(), block.end());
	}

	return methods;
}


//--------------------------------------


FileGenerator::FileGenerator(const string& filename, const string& prefix)
	: prefix(prefix)
{
	out = fopen(filename.c_str(), "w+");

	if (!out)
		throw runtime_error(string("Error creating output file '") + filename + "'.");
}

FileGenerator::~FileGenerator()
{
	fclose(out);
}


//--------------------------------------


CBasedGenerator::CBasedGenerator(const string& filename, const string& prefix, bool cPlusPlus)
	: FileGenerator(filename, prefix),
	  cPlusPlus(cPlusPlus)
{
}

string CBasedGenerator::convertType(const TypeRef& typeRef)
{
	string ret(typeRef.isConst ? "const " : "");

	switch (typeRef.token.type)
	{
		case Token::Type::BOOLEAN:
			ret += "FB_BOOLEAN";  // seems to be more portable than bool, specially thinking on pointers
			break;

		case Token::Type::INT:
			ret += "int";
			break;

		case Token::Type::INT64:
			ret += "ISC_INT64";  // int64_t
			break;

		case Token::Type::INTPTR:
			ret += "intptr_t";
			break;

		case Token::Type::STRING:
			ret += "char*";
			break;

		case Token::Type::UCHAR:
			ret += "unsigned char";
			break;

		case Token::Type::UINT:
			ret += "unsigned";
			break;

		case Token::Type::UINT64:
			ret += "ISC_UINT64";  // uint64_t
			break;

		case Token::Type::IDENTIFIER:
			ret += string(cPlusPlus || typeRef.type == BaseType::Type::TYPEDEF ? "" : "struct ") +
				(typeRef.type == BaseType::Type::INTERFACE ? prefix : "") + typeRef.token.text;

			if (typeRef.type == BaseType::Type::INTERFACE)
				ret += "*";
			break;

		default:
			ret += typeRef.token.text;
			break;
	}

	if (typeRef.isPointer)
		ret += "*";

	return ret;
}


//--------------------------------------


CppGenerator::CppGenerator(
	const string& filename, const string& prefix, Parser* parser, const string& headerGuard, const string& nameSpace)
	: CBasedGenerator(filename, prefix, true),
	  parser(parser),
	  headerGuard(headerGuard),
	  nameSpace(nameSpace)
{
}

void CppGenerator::generate()
{
	string nameSpaceUpper = nameSpace;
	transform(nameSpaceUpper.begin(), nameSpaceUpper.end(), nameSpaceUpper.begin(), toupper);
	const auto& interfaces = parser->interfaces;

	fprintf(out, "// %s\n\n", AUTOGEN_MSG);

	fprintf(out, "#ifndef %s\n", headerGuard.c_str());
	fprintf(out, "#define %s\n\n", headerGuard.c_str());
	/// fprintf(out, "#include <stdint.h>\n\n");

	fprintf(out, "#ifndef CLOOP_CARG\n");
	fprintf(out, "#define CLOOP_CARG\n");
	fprintf(out, "#endif\n\n");

	fprintf(out, "#ifndef CLOOP_NOEXCEPT\n");
	fprintf(out, "#if __cplusplus >= 201103L\n");
	fprintf(out, "#define CLOOP_NOEXCEPT noexcept\n");
	fprintf(out, "#else\n");
	fprintf(out, "#define CLOOP_NOEXCEPT throw()\n");
	fprintf(out, "#endif\n");
	fprintf(out, "#endif\n\n\n");

	fprintf(out, "#ifndef CLOOP_CONSTEXPR\n");
	fprintf(out, "#if __cplusplus >= 201703L\n");
	fprintf(out, "#define CLOOP_CONSTEXPR inline constexpr\n");
	fprintf(out, "#elif __cplusplus >= 201103L\n");
	fprintf(out, "#define CLOOP_CONSTEXPR constexpr\n");
	fprintf(out, "#else\n");
	fprintf(out, "#define CLOOP_CONSTEXPR const\n");
	fprintf(out, "#endif\n");
	fprintf(out, "#endif\n\n\n");

	fprintf(out, "namespace %s\n", nameSpace.c_str());
	fprintf(out, "{\n");
	fprintf(out, "\tclass DoNotInherit\n");
	fprintf(out, "\t{\n");
	fprintf(out, "\t};\n");
	fprintf(out, "\n");
	fprintf(out, "\ttemplate <typename T>\n");
	fprintf(out, "\tclass Inherit : public T\n");
	fprintf(out, "\t{\n");
	fprintf(out, "\tpublic:\n");
	fprintf(out, "\t\tInherit(DoNotInherit = DoNotInherit())\n");
	fprintf(out, "\t\t\t: T(DoNotInherit())\n");
	fprintf(out, "\t\t{\n");
	fprintf(out, "\t\t}\n");
	fprintf(out, "\t};\n");
	fprintf(out, "\n");

	fprintf(out, "\t// Forward interfaces declarations\n\n");

	for (const auto& interface : interfaces)
		fprintf(out, "\tclass %s%s;\n", prefix.c_str(), interface->name.c_str());

	fprintf(out, "\n");
	fprintf(out, "\t// Interfaces declarations\n\n");

	for (const auto& interface : interfaces)
	{
		const string snakeInterfaceName = snakeUpperCase(interface->name);
		const auto& interfaceMethods = interface->methods;
		const auto& interfaceConstants = interface->constants;

		fprintf(out, "#define %s_%s%s_VERSION %uu\n\n", nameSpaceUpper.c_str(), prefix.c_str(),
			snakeInterfaceName.c_str(), interface->version);

		const auto methods = collectInterfaceMethods(interface.get());

		if (!interface->super)
			fprintf(out, "\tclass %s%s\n", prefix.c_str(), interface->name.c_str());
		else
		{
			fprintf(out, "\tclass %s%s : public %s%s\n", prefix.c_str(), interface->name.c_str(), prefix.c_str(),
				interface->super->name.c_str());
		}

		fprintf(out, "\t{\n");
		fprintf(out, "\tpublic:\n");

		if (!interface->super)
		{
			fprintf(out, "\t\tstruct VTable\n");
			fprintf(out, "\t\t{\n");
			fprintf(out, "\t\t\tvoid* cloopDummy[%d];\n", DUMMY_VTABLE);
			fprintf(out, "\t\t\tuintptr_t version;\n");
		}
		else
		{
			fprintf(out, "\t\tstruct VTable : public %s%s::VTable\n", prefix.c_str(), interface->super->name.c_str());
			fprintf(out, "\t\t{\n");
		}

		for (const auto& methodPtr : interfaceMethods)
		{
			Method* method = methodPtr.get();
			const auto& parameters = method->parameters;

			fprintf(out, "\t\t\t%s (CLOOP_CARG *%s)(%s%s%s* self", convertType(method->returnTypeRef).c_str(),
				method->name.c_str(), (method->isConst ? "const " : ""), prefix.c_str(), interface->name.c_str());

			for (const auto& parameter : parameters)
				fprintf(out, ", %s %s", convertType(parameter->typeRef).c_str(), parameter->name.c_str());

			fprintf(out, ") CLOOP_NOEXCEPT;\n");
		}

		fprintf(out, "\t\t};\n");
		fprintf(out, "\n");

		if (!interface->super)
		{
			fprintf(out, "\t\tvoid* cloopDummy[%d];\n", DUMMY_INSTANCE);
			fprintf(out, "\t\tVTable* cloopVTable;\n");
			fprintf(out, "\n");
		}

		fprintf(out, "\tprotected:\n");
		fprintf(out, "\t\t%s%s(DoNotInherit)\n", prefix.c_str(), interface->name.c_str());

		if (interface->super)
			fprintf(out, "\t\t\t: %s%s(DoNotInherit())\n", prefix.c_str(), interface->super->name.c_str());

		fprintf(out, "\t\t{\n");
		fprintf(out, "\t\t}\n");
		fprintf(out, "\n");
		fprintf(out, "\t\t~%s%s()\n", prefix.c_str(), interface->name.c_str());
		fprintf(out, "\t\t{\n");
		fprintf(out, "\t\t}\n");
		fprintf(out, "\n");

		fprintf(out, "\tpublic:\n");

		fprintf(out, "\t\tstatic CLOOP_CONSTEXPR unsigned VERSION = %s_%s%s_VERSION;\n", nameSpaceUpper.c_str(),
			prefix.c_str(), snakeInterfaceName.c_str());

		if (!interface->constants.empty())
			fprintf(out, "\n");

		for (const auto& constantPtr : interfaceConstants)
		{
			const Constant* constant = constantPtr.get();
			fprintf(out, "\t\tstatic CLOOP_CONSTEXPR %s %s = %s;\n", convertType(constant->typeRef).c_str(),
				constant->name.c_str(), constant->expr->generate(Language::CPP, prefix).c_str());
		}

		for (const auto& methodPtr : interfaceMethods)
		{
			Method* method = methodPtr.get();
			const auto& parameters = method->parameters;

			fprintf(out, "\n\t\t");

			if (!method->statusName.empty())
				fprintf(out, "template <typename StatusType> ");

			fprintf(out, "%s %s(", convertType(method->returnTypeRef).c_str(), method->name.c_str());

			for (size_t k = 0; k < parameters.size(); ++k)
			{
				const auto* parameter = parameters[k].get();

				if (k != 0)
					fprintf(out, ", ");

				if (k == 0 && !method->statusName.empty())
					fprintf(out, "StatusType* %s", parameter->name.c_str());
				else
					fprintf(out, "%s %s", convertType(parameter->typeRef).c_str(), parameter->name.c_str());
			}

			fprintf(out, ")%s\n", (method->isConst ? " const" : ""));
			fprintf(out, "\t\t{\n");

			if (method->version - (interface->super ? interface->super->version : 0) != 1)
			{
				fprintf(out, "\t\t\tif (cloopVTable->version < %d)\n", method->version);
				fprintf(out, "\t\t\t{\n");

				const string exceptionClass("StatusType");
				ActionParametersBlock apb = {out, Language::CPP, prefix, exceptionClass, interface.get(), method};

				if (method->notImplementedAction)
					method->notImplementedAction->generate(apb, 4);
				else
					DefAction(DefAction::DefType::NOT_IMPLEMENTED).generate(apb, 4);

				fprintf(out, "\t\t\t\treturn");

				if (method->returnTypeRef.token.type != Token::Type::VOID || method->returnTypeRef.isPointer)
				{
					fprintf(out, " %s",
						(method->notImplementedExpr
								? method->notImplementedExpr->generate(Language::CPP, prefix).c_str()
								: "0"));
				}

				fprintf(out, ";\n");
				fprintf(out, "\t\t\t}\n");
			}

			if (!method->statusName.empty())
			{
				fprintf(out, "\t\t\t");

				fprintf(out, "StatusType::clearException(%s)", method->statusName.c_str());

				fprintf(out, ";\n");
			}

			fprintf(out, "\t\t\t");

			if (method->returnTypeRef.token.type != Token::Type::VOID || method->returnTypeRef.isPointer)
			{
				fprintf(out, "%s ret = ", convertType(method->returnTypeRef).c_str());
			}

			fprintf(out, "static_cast<VTable*>(this->cloopVTable)->%s(this", method->name.c_str());

			for (const auto& parameter : parameters)
				fprintf(out, ", %s", parameter->name.c_str());

			fprintf(out, ")");
			fprintf(out, ";\n");

			if (!method->parameters.empty() && parser->exceptionInterface &&
				method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name)
			{
				fprintf(out, "\t\t\tStatusType::checkException(%s);\n", method->parameters.front()->name.c_str());
			}

			if (method->returnTypeRef.token.type != Token::Type::VOID || method->returnTypeRef.isPointer)
				fprintf(out, "\t\t\treturn ret;\n");

			fprintf(out, "\t\t}\n");
		}

		fprintf(out, "\t};\n\n");
	}

	fprintf(out, "\t// Interfaces implementations\n");

	for (const auto& interface : interfaces)
	{
		const auto methods = collectInterfaceMethods(interface.get());

		fprintf(out, "\n");
		fprintf(out, "\ttemplate <typename Name, typename StatusType, typename Base>\n");
		fprintf(out, "\tclass %s%sBaseImpl : public Base\n", prefix.c_str(), interface->name.c_str());
		fprintf(out, "\t{\n");
		fprintf(out, "\tpublic:\n");
		fprintf(out, "\t\ttypedef %s%s Declaration;\n", prefix.c_str(), interface->name.c_str());
		fprintf(out, "\n");
		fprintf(out, "\t\t%s%sBaseImpl(DoNotInherit = DoNotInherit())\n", prefix.c_str(), interface->name.c_str());
		fprintf(out, "\t\t{\n");
		fprintf(out, "\t\t\tstatic struct VTableImpl : Base::VTable\n");
		fprintf(out, "\t\t\t{\n");
		fprintf(out, "\t\t\t\tVTableImpl()\n");
		fprintf(out, "\t\t\t\t{\n");
		fprintf(out, "\t\t\t\t\tthis->version = Base::VERSION;\n");

		for (Method* method : methods)
		{
			fprintf(
				out, "\t\t\t\t\tthis->%s = &Name::cloop%sDispatcher;\n", method->name.c_str(), method->name.c_str());
		}

		fprintf(out, "\t\t\t\t}\n");
		fprintf(out, "\t\t\t} vTable;\n");
		fprintf(out, "\n");

		fprintf(out, "\t\t\tthis->cloopVTable = &vTable;\n");
		fprintf(out, "\t\t}\n");

		// We generate all bases dispatchers so indirect overrides work. At the same time, we
		// inherit from all bases impls, so pure virtual methods are introduced and required to
		// be overriden in the user's implementation.

		for (const auto* p = interface.get(); p; p = p->super)
		{
			for (const auto& method : p->methods)
			{
				fprintf(out, "\n");
				fprintf(out, "\t\tstatic %s CLOOP_CARG cloop%sDispatcher(%s%s%s* self",
					convertType(method->returnTypeRef).c_str(), method->name.c_str(), (method->isConst ? "const " : ""),
					prefix.c_str(), p->name.c_str());

				for (const auto& parameter : method->parameters)
					fprintf(out, ", %s %s", convertType(parameter->typeRef).c_str(), parameter->name.c_str());

				auto* exceptionParameter =
					(!method->parameters.empty() && parser->exceptionInterface &&
						method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name)
					? method->parameters.front().get()
					: nullptr;

				fprintf(out, ") CLOOP_NOEXCEPT\n");
				fprintf(out, "\t\t{\n");

				if (exceptionParameter)
				{
					fprintf(out, "\t\t\tStatusType %s2(%s);\n", exceptionParameter->name.c_str(),
						exceptionParameter->name.c_str());
					fprintf(out, "\n");
				}

				fprintf(out, "\t\t\ttry\n");
				fprintf(out, "\t\t\t{\n");

				fprintf(out, "\t\t\t\t");

				if (method->returnTypeRef.token.type != Token::Type::VOID || method->returnTypeRef.isPointer)
					fprintf(out, "return ");

				fprintf(out, "static_cast<%sName*>(self)->Name::%s(", (method->isConst ? "const " : ""),
					method->name.c_str());

				for (const auto& parameter : method->parameters)
				{
					if (parameter != method->parameters.front())
						fprintf(out, ", ");

					if (parameter.get() == exceptionParameter)
						fprintf(out, "&%s2", parameter->name.c_str());
					else
						fprintf(out, "%s", parameter->name.c_str());
				}

				fprintf(out, ");\n");

				fprintf(out, "\t\t\t}\n");
				fprintf(out, "\t\t\tcatch (...)\n");
				fprintf(out, "\t\t\t{\n");
				fprintf(out, "\t\t\t\tStatusType::catchException(%s);\n",
					(exceptionParameter ? ("&" + exceptionParameter->name + "2").c_str() : "0"));

				if (method->returnTypeRef.token.type != Token::Type::VOID || method->returnTypeRef.isPointer)
				{
					const char* ret = "\t\t\t\treturn";
					if (method->onErrorFunction.length())
						fprintf(out, "%s %s();\n", ret, method->onErrorFunction.c_str());
					else
						fprintf(out, "%s static_cast<%s>(0);\n", ret, convertType(method->returnTypeRef).c_str());
				}

				fprintf(out, "\t\t\t}\n");

				fprintf(out, "\t\t}\n");
			}
		}

		fprintf(out, "\t};\n\n");

		if (!interface->super)
		{
			fprintf(out, "\ttemplate <typename Name, typename StatusType, typename Base = Inherit<%s%s> >\n",
				prefix.c_str(), interface->name.c_str());
		}
		else
		{
			string base;
			unsigned baseCount = 0;

			for (const auto* p = interface->super; p; p = p->super)
			{
				base += prefix + p->name + "Impl<Name, StatusType, Inherit<";
				++baseCount;
			}

			base += prefix.c_str() + interface->name;

			while (baseCount-- > 0)
				base += "> > ";

			fprintf(out, "\ttemplate <typename Name, typename StatusType, typename Base = %s>\n", base.c_str());
		}

		fprintf(out, "\tclass %s%sImpl : public %s%sBaseImpl<Name, StatusType, Base>\n", prefix.c_str(),
			interface->name.c_str(), prefix.c_str(), interface->name.c_str());
		fprintf(out, "\t{\n");
		fprintf(out, "\tprotected:\n");
		fprintf(out, "\t\t%s%sImpl(DoNotInherit = DoNotInherit())\n", prefix.c_str(), interface->name.c_str());
		fprintf(out, "\t\t{\n");
		fprintf(out, "\t\t}\n");
		fprintf(out, "\n");
		fprintf(out, "\tpublic:\n");
		fprintf(out, "\t\tvirtual ~%s%sImpl()\n", prefix.c_str(), interface->name.c_str());
		fprintf(out, "\t\t{\n");
		fprintf(out, "\t\t}\n");
		fprintf(out, "\n");

		const auto& interfaceMethods = interface->methods;

		for (const auto& method : interfaceMethods)
		{
			auto* exceptionParameter =
				(!method->parameters.empty() && parser->exceptionInterface &&
					method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name)
				? method->parameters.front().get()
				: nullptr;

			fprintf(out, "\t\tvirtual %s %s(", convertType(method->returnTypeRef).c_str(), method->name.c_str());

			const auto& parameters = method->parameters;

			for (size_t k = 0; k < parameters.size(); ++k)
			{
				auto* parameter = parameters[k].get();

				if (k != 0)
					fprintf(out, ", ");

				if (parameter == exceptionParameter)
					fprintf(out, "StatusType* %s", parameter->name.c_str());
				else
					fprintf(out, "%s %s", convertType(parameter->typeRef).c_str(), parameter->name.c_str());
			}

			fprintf(out, ")%s", (method->isConst ? " const" : ""));

			if (method->stubAction)
			{
				const string exceptionClass("StatusType");
				ActionParametersBlock apb = {out, Language::CPP, prefix, exceptionClass, interface.get(), method.get()};

				fprintf(out, "\n\t\t{\n");
				method->stubAction->generate(apb, 3);
				fprintf(out, "\t\t}\n");
			}
			else
				fprintf(out, " = 0;\n");
		}

		fprintf(out, "\t};\n");
	}

	fprintf(out, "};\n\n");
	fprintf(out, "\n");

	fprintf(out, "#endif\t// %s\n", headerGuard.c_str());
}


//--------------------------------------


CHeaderGenerator::CHeaderGenerator(const string& filename, const string& prefix, Parser* parser,
	const string& headerGuard, const std::string& parMacro)
	: CBasedGenerator(filename, prefix, false),
	  parser(parser),
	  headerGuard(headerGuard),
	  macro(false)
{
	if (parMacro.length() > 0 && parMacro != "macro")
		throw runtime_error("Last (#6) param should be exactly 'macro' or missing");

	macro = parMacro.length() > 0;
}

void CHeaderGenerator::generate()
{
	fprintf(out, "/* %s */\n\n", AUTOGEN_MSG);

	fprintf(out, "#ifndef %s\n", headerGuard.c_str());
	fprintf(out, "#define %s\n\n", headerGuard.c_str());
	fprintf(out, "#include <stdint.h>\n\n");

	fprintf(out, "#ifndef CLOOP_EXTERN_C\n");
	fprintf(out, "#ifdef __cplusplus\n");
	fprintf(out, "#define CLOOP_EXTERN_C extern \"C\"\n");
	fprintf(out, "#else\n");
	fprintf(out, "#define CLOOP_EXTERN_C\n");
	fprintf(out, "#endif\n");
	fprintf(out, "#endif\n\n\n");

	const auto& interfaces = parser->interfaces;

	for (const auto& interface : interfaces)
		fprintf(out, "struct %s%s;\n", prefix.c_str(), interface->name.c_str());

	fprintf(out, "\n\n");

	for (const auto& interface : interfaces)
	{
		const auto& interfaceConstants = interface->constants;

		const auto methods = collectInterfaceMethods(interface.get());

		fprintf(out, "#define %s%s_VERSION %d\n\n", prefix.c_str(), interface->name.c_str(), interface->version);

		for (const auto& constant : interfaceConstants)
		{
			fprintf(out, "#define %s%s_%s ((%s) (%s))\n", prefix.c_str(), interface->name.c_str(),
				constant->name.c_str(), convertType(constant->typeRef).c_str(),
				constant->expr->generate(Language::C, prefix).c_str());
		}

		if (!interface->constants.empty())
			fprintf(out, "\n");

		fprintf(out, "struct %s%s;\n\n", prefix.c_str(), interface->name.c_str());

		fprintf(out, "struct %s%sVTable\n", prefix.c_str(), interface->name.c_str());
		fprintf(out, "{\n");
		fprintf(out, "\tvoid* cloopDummy[%d];\n", DUMMY_VTABLE);
		fprintf(out, "\tuintptr_t version;\n");

		for (Method* method : methods)
		{
			const auto& parameters = method->parameters;

			fprintf(out, "\t%s (*%s)(%sstruct %s%s* self", convertType(method->returnTypeRef).c_str(),
				method->name.c_str(), (method->isConst ? "const " : ""), prefix.c_str(), interface->name.c_str());

			for (const auto& parameter : parameters)
				fprintf(out, ", %s %s", convertType(parameter->typeRef).c_str(), parameter->name.c_str());

			fprintf(out, ");\n");
		}

		fprintf(out, "};\n\n");

		fprintf(out, "struct %s%s\n", prefix.c_str(), interface->name.c_str());
		fprintf(out, "{\n");
		fprintf(out, "\tvoid* cloopDummy[%d];\n", DUMMY_INSTANCE);
		fprintf(out, "\tstruct %s%sVTable* vtable;\n", prefix.c_str(), interface->name.c_str());
		fprintf(out, "};\n\n");

		for (Method* method : methods)
		{
			const auto& parameters = method->parameters;

			if (macro)
				fprintf(out, "#define %s%s_%s(self", prefix.c_str(), interface->name.c_str(), method->name.c_str());
			else
			{
				fprintf(out, "CLOOP_EXTERN_C %s %s%s_%s(%sstruct %s%s* self",
					convertType(method->returnTypeRef).c_str(), prefix.c_str(), interface->name.c_str(),
					method->name.c_str(), (method->isConst ? "const " : ""), prefix.c_str(), interface->name.c_str());
			}

			for (const auto& parameter : parameters)
			{
				if (macro)
					fprintf(out, ", %s", parameter->name.c_str());
				else
					fprintf(out, ", %s %s", convertType(parameter->typeRef).c_str(), parameter->name.c_str());
			}

			if (macro)
			{
				fprintf(out, ") %s(self)->vtable->%s(self",
					method->returnTypeRef.token.type != Token::Type::VOID ? "(" : "", method->name.c_str());

				for (const auto& parameter : parameters)
					fprintf(out, ", (%s)", parameter->name.c_str());

				fprintf(out, ")%s\n", method->returnTypeRef.token.type != Token::Type::VOID ? ")" : "");
			}
			else
				fprintf(out, ");\n");
		}

		fprintf(out, "\n");
	}

	fprintf(out, "\n");
	fprintf(out, "#endif\t// %s\n", headerGuard.c_str());
}


//--------------------------------------


CImplGenerator::CImplGenerator(
	const string& filename, const string& prefix, Parser* parser, const string& includeFilename)
	: CBasedGenerator(filename, prefix, false),
	  parser(parser),
	  includeFilename(includeFilename)
{
}

void CImplGenerator::generate()
{
	fprintf(out, "/* %s */\n\n", AUTOGEN_MSG);

	fprintf(out, "#include \"%s\"\n\n\n", includeFilename.c_str());

	const auto& interfaces = parser->interfaces;

	for (const auto& interface : interfaces)
	{
		const auto methods = collectInterfaceMethods(interface.get());

		for (const auto method : methods)
		{
			const auto& parameters = method->parameters;

			fprintf(out, "CLOOP_EXTERN_C %s %s%s_%s(%sstruct %s%s* self", convertType(method->returnTypeRef).c_str(),
				prefix.c_str(), interface->name.c_str(), method->name.c_str(), (method->isConst ? "const " : ""),
				prefix.c_str(), interface->name.c_str());

			for (const auto& parameter : parameters)
			{
				fprintf(out, ", %s %s", convertType(parameter->typeRef).c_str(), parameter->name.c_str());
			}

			fprintf(out, ")\n");
			fprintf(out, "{\n");
			fprintf(out, "\t");

			//// TODO: checkVersion

			if (method->returnTypeRef.token.type != Token::Type::VOID || method->returnTypeRef.isPointer)
			{
				fprintf(out, "return ");
			}

			fprintf(out, "self->vtable->%s(self", method->name.c_str());

			for (const auto& parameter : method->parameters)
				fprintf(out, ", %s", parameter->name.c_str());

			fprintf(out, ");\n");
			fprintf(out, "}\n\n");
		}
	}
}


//--------------------------------------


PascalGenerator::PascalGenerator(const string& filename, const string& prefix, Parser* parser, const string& unitName,
	const std::string& additionalUses, const std::string& interfaceFile, const std::string& implementationFile,
	const std::string& exceptionClass, const std::string& functionsFile)
	: FileGenerator(filename, prefix),
	  parser(parser),
	  unitName(unitName),
	  additionalUses(additionalUses),
	  interfaceFile(interfaceFile),
	  implementationFile(implementationFile),
	  exceptionClass(exceptionClass),
	  functionsFile(functionsFile)
{
}

void PascalGenerator::generate()
{
	fprintf(out, "{ %s }\n\n", AUTOGEN_MSG);

	fprintf(out, "{$IFDEF FPC}\n{$MODE DELPHI}\n{$OBJECTCHECKS OFF}\n{$ENDIF}\n\n");

	fprintf(out, "unit %s;\n\n", unitName.c_str());
	fprintf(out, "interface\n\n");
	fprintf(out, "uses Classes");

	if (!additionalUses.empty())
		fprintf(out, ", %s", additionalUses.c_str());

	fprintf(out, ";\n\n");

	fprintf(out, "type\n");
	fprintf(out, "{$IFNDEF FPC}\n");
	fprintf(out, "\tQWord = UInt64;\n");
	fprintf(out, "{$ENDIF}\n\n");

	for (const auto& interface : parser->interfaces)
		fprintf(out, "\t%s = class;\n", escapeIfaceName(interface->name).c_str());

	fprintf(out, "\n");

	insertFile(interfaceFile);

	// Pass at every type to fill pointerTypes. We need it in advance.

	for (const auto& interface : parser->interfaces)
	{
		const auto& interfaceMethods = interface->methods;

		for (const auto& methodPtr : interfaceMethods)
		{
			Method* method = methodPtr.get();

			convertType(method->returnTypeRef);

			for (const auto& parameter : method->parameters)
				convertParameter(*parameter);
		}
	}

	const auto& interfaces = parser->interfaces;

	for (set<string>::iterator i = pointerTypes.begin(); i != pointerTypes.end(); ++i)
	{
		string type = *i;
		fprintf(out, "\t%sPtr = ^%s;\n", type.c_str(), type.c_str());
	}

	if (!pointerTypes.empty())
		fprintf(out, "\n");

	for (const auto& interface : interfaces)
	{
		const auto& interfaceMethods = interface->methods;

		for (const auto& method : interfaceMethods)
		{
			const auto& parameters = method->parameters;

			bool isProcedure =
				method->returnTypeRef.token.type == Token::Type::VOID && !method->returnTypeRef.isPointer;

			fprintf(out, "\t%s_%sPtr = %s(this: %s", escapeIfaceName(interface->name).c_str(),
				escapeName(method->name).c_str(), (isProcedure ? "procedure" : "function"),
				escapeIfaceName(interface->name).c_str());

			for (const auto& parameter : parameters)
				fprintf(out, "; %s", convertParameter(*parameter).c_str());

			fprintf(out, ")");

			if (!isProcedure)
				fprintf(out, ": %s", convertType(method->returnTypeRef).c_str());

			fprintf(out, "; cdecl;\n");
		}
	}

	fprintf(out, "\n");

	for (const auto& interface : interfaces)
	{
		const auto& interfaceMethods = interface->methods;
		const auto& interfaceConstants = interface->constants;

		fprintf(out, "\t%sVTable = class", escapeName(interface->name).c_str());

		if (interface->super)
			fprintf(out, "(%sVTable)", escapeName(interface->super->name).c_str());

		fprintf(out, "\n");

		if (!interface->super)
			fprintf(out, "\t\tversion: NativeInt;\n");

		for (const auto& method : interfaceMethods)
		{
			fprintf(out, "\t\t%s: %s_%sPtr;\n", escapeName(method->name).c_str(),
				escapeIfaceName(interface->name).c_str(), escapeName(method->name).c_str());
		}

		fprintf(out, "\tend;\n\n");

		fprintf(out, "\t%s = class", escapeIfaceName(interface->name).c_str());

		if (interface->super)
			fprintf(out, "(%s)", escapeIfaceName(interface->super->name).c_str());

		fprintf(out, "\n");

		if (!interface->super)
			fprintf(out, "\t\tvTable: %sVTable;\n\n", escapeName(interface->name).c_str());

		fprintf(out, "\t\tconst VERSION = %d;\n", interface->version);

		for (const auto& constant : interfaceConstants)
		{
			fprintf(out, "\t\tconst %s = %s(%s);\n", constant->name.c_str(), convertType(constant->typeRef).c_str(),
				constant->expr->generate(Language::PASCAL, prefix).c_str());
		}

		fprintf(out, "\n");

		for (const auto& method : interfaceMethods)
		{
			const auto& parameters = method->parameters;

			bool isProcedure =
				method->returnTypeRef.token.type == Token::Type::VOID && !method->returnTypeRef.isPointer;

			fprintf(out, "\t\t%s %s(", (isProcedure ? "procedure" : "function"), escapeName(method->name).c_str());

			for (size_t k = 0; k < parameters.size(); ++k)
			{
				const auto& parameter = parameters[k];

				if (k != 0)
					fprintf(out, "; ");

				fprintf(out, "%s", convertParameter(*parameter).c_str());
			}

			fprintf(out, ")");

			if (!isProcedure)
				fprintf(out, ": %s", convertType(method->returnTypeRef).c_str());

			// Methods that present in TObject should be "reintroduce"d.
			// So far there is just one case. For more cases better solution required.

			if (method->name == "toString")
				fprintf(out, "; reintroduce");

			fprintf(out, ";\n");
		}

		fprintf(out, "\tend;\n\n");

		fprintf(out, "\t%sImpl = class(%s)\n", escapeIfaceName(interface->name).c_str(),
			escapeIfaceName(interface->name).c_str());
		fprintf(out, "\t\tconstructor create;\n\n");

		const auto methods = collectInterfaceMethods(interface.get());

		for (Method* method : methods)
		{
			const auto& parameters = method->parameters;

			bool isProcedure =
				method->returnTypeRef.token.type == Token::Type::VOID && !method->returnTypeRef.isPointer;

			fprintf(out, "\t\t%s %s(", (isProcedure ? "procedure" : "function"), escapeName(method->name).c_str());

			for (size_t k = 0; k < parameters.size(); ++k)
			{
				const auto& parameter = parameters[k];

				if (k != 0)
					fprintf(out, "; ");

				fprintf(out, "%s", convertParameter(*parameter).c_str());
			}

			fprintf(out, ")");

			if (!isProcedure)
				fprintf(out, ": %s", convertType(method->returnTypeRef).c_str());

			fprintf(out, "; virtual;");
			if (!method->stubAction)
				fprintf(out, " abstract;");
			fprintf(out, "\n");
		}

		fprintf(out, "\tend;\n\n");
	}

	insertFile(functionsFile);

	fprintf(out, "implementation\n\n");

	for (const auto& interface : parser->interfaces)
	{
		for (const auto& method : interface->methods)
		{
			bool isProcedure =
				method->returnTypeRef.token.type == Token::Type::VOID && !method->returnTypeRef.isPointer;

			fprintf(out, "%s %s.%s(", (isProcedure ? "procedure" : "function"),
				escapeIfaceName(interface->name).c_str(), escapeName(method->name).c_str());

			for (const auto& parameter : method->parameters)
			{
				if (&parameter != &method->parameters.front())
					fprintf(out, "; ");

				fprintf(out, "%s", convertParameter(*parameter).c_str());
			}

			fprintf(out, ")");

			if (!isProcedure)
				fprintf(out, ": %s", convertType(method->returnTypeRef).c_str());

			fprintf(out, ";\n");
			fprintf(out, "begin\n");

			unsigned ident = 1;
			if (method->version - (interface->super ? interface->super->version : 0) != 1)
			{
				fprintf(out, "\tif (vTable.version < %d) then begin\n", method->version);

				ActionParametersBlock apb = {
					out, Language::PASCAL, prefix, exceptionClass, interface.get(), method.get()};

				if (method->notImplementedAction)
					method->notImplementedAction->generate(apb, 2);
				else
					DefAction(DefAction::DefType::NOT_IMPLEMENTED).generate(apb, 2);

				if (method->returnTypeRef.token.type != Token::Type::VOID || method->returnTypeRef.isPointer)
				{
					fprintf(out, "\t\tResult := %s;\n",
						method->notImplementedExpr
							? method->notImplementedExpr->generate(Language::PASCAL, prefix).c_str()
							: method->returnTypeRef.valueIsPointer()                   ? "nil"
							: method->returnTypeRef.token.type == Token::Type::BOOLEAN ? "false"
																					   : "0");
				}

				fprintf(out, "\tend\n\telse begin\n");
				ident = 2;
			}

			identify(out, ident);
			if (!isProcedure)
				fprintf(out, "Result := ");

			fprintf(
				out, "%sVTable(vTable).%s(Self", escapeName(interface->name).c_str(), escapeName(method->name).c_str());

			for (const auto& parameter : method->parameters)
				fprintf(out, ", %s", escapeName(parameter->name).c_str());

			fprintf(out, ");\n");

			if (ident > 1)
				fprintf(out, "\tend;\n");

			if (!method->statusName.empty() && !exceptionClass.empty())
				fprintf(
					out, "\t%s.checkException(%s);\n", exceptionClass.c_str(), escapeName(method->statusName).c_str());

			fprintf(out, "end;\n\n");
		}
	}

	for (const auto& interface : parser->interfaces)
	{
		const auto methods = collectInterfaceMethods(interface.get());

		for (const auto method : methods)
		{
			bool isProcedure =
				method->returnTypeRef.token.type == Token::Type::VOID && !method->returnTypeRef.isPointer;

			ActionParametersBlock apb = {out, Language::PASCAL, prefix, exceptionClass, interface.get(), method};

			fprintf(out, "%s %sImpl_%sDispatcher(this: %s", (isProcedure ? "procedure" : "function"),
				escapeIfaceName(interface->name).c_str(), escapeName(method->name).c_str(),
				escapeIfaceName(interface->name).c_str());

			for (const auto& parameter : method->parameters)
				fprintf(out, "; %s", convertParameter(*parameter).c_str());

			fprintf(out, ")");

			if (!isProcedure)
				fprintf(out, ": %s", convertType(method->returnTypeRef).c_str());

			fprintf(out, "; cdecl;\n");
			fprintf(out, "begin\n");
			DefAction(DefAction::DefType::IGNORE).generate(apb, 1);

			if (!exceptionClass.empty())
				fprintf(out, "\ttry\n\t");

			fprintf(out, "\t");

			if (!isProcedure)
				fprintf(out, "Result := ");

			fprintf(
				out, "%sImpl(this).%s(", escapeIfaceName(interface->name).c_str(), escapeName(method->name).c_str());

			for (const auto& parameter : method->parameters)
			{
				if (&parameter != &method->parameters.front())
					fprintf(out, ", ");

				fprintf(out, "%s", escapeName(parameter->name).c_str());
			}

			fprintf(out, ");\n");

			if (!exceptionClass.empty())
			{
				auto* exceptionParameter =
					(!method->parameters.empty() && parser->exceptionInterface &&
						method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name)
					? method->parameters.front().get()
					: nullptr;

				fprintf(out, "\texcept\n");
				fprintf(out, "\t\ton e: Exception do %s.catchException(%s, e);\n", exceptionClass.c_str(),
					(exceptionParameter ? escapeName(exceptionParameter->name).c_str() : "nil"));

				fprintf(out, "\tend\n");
			}

			fprintf(out, "end;\n\n");

			if (method->stubAction)
			{
				fprintf(out, "%s %sImpl.%s(", (isProcedure ? "procedure" : "function"),
					escapeIfaceName(interface->name).c_str(), escapeName(method->name).c_str());

				for (const auto& parameter : method->parameters)
				{
					fprintf(out, "%s%s", &parameter != &method->parameters.front() ? "; " : "",
						convertParameter(*parameter).c_str());
				}

				fprintf(out, ")");
				if (!isProcedure)
					fprintf(out, ": %s", convertType(method->returnTypeRef).c_str());
				fprintf(out, ";\n");

				fprintf(out, "begin\n");
				method->stubAction->generate(apb, 1);
				fprintf(out, "end;\n\n");
			}
		}

		fprintf(out, "var\n");
		fprintf(out, "\t%sImpl_vTable: %sVTable;\n\n", escapeIfaceName(interface->name).c_str(),
			escapeName(interface->name).c_str());

		fprintf(out, "constructor %sImpl.create;\n", escapeIfaceName(interface->name).c_str());
		fprintf(out, "begin\n");
		fprintf(out, "\tvTable := %sImpl_vTable;\n", escapeIfaceName(interface->name).c_str());
		fprintf(out, "end;\n\n");
	}

	insertFile(implementationFile);

	fprintf(out, "initialization\n");

	for (const auto& interface : parser->interfaces)
	{
		const auto methods = collectInterfaceMethods(interface.get());

		fprintf(out, "\t%sImpl_vTable := %sVTable.create;\n", escapeIfaceName(interface->name).c_str(),
			escapeName(interface->name).c_str());
		fprintf(out, "\t%sImpl_vTable.version := %d;\n", escapeIfaceName(interface->name).c_str(), interface->version);

		for (const auto& method : methods)
		{
			fprintf(out, "\t%sImpl_vTable.%s := @%sImpl_%sDispatcher;\n", escapeIfaceName(interface->name).c_str(),
				escapeName(method->name).c_str(), escapeIfaceName(interface->name).c_str(),
				escapeName(method->name).c_str());
		}

		fprintf(out, "\n");
	}

	fprintf(out, "finalization\n");

	for (const auto& interface : parser->interfaces)
		fprintf(out, "\t%sImpl_vTable.destroy;\n", escapeIfaceName(interface->name).c_str());

	fprintf(out, "\n");
	fprintf(out, "end.\n");
}

string PascalGenerator::convertParameter(const Parameter& parameter)
{
	return escapeName(parameter.name) + ": " + convertType(parameter.typeRef);
}

string PascalGenerator::convertType(const TypeRef& typeRef)
{
	string name;

	switch (typeRef.token.type)
	{
		case Token::Type::BOOLEAN:
			name = "Boolean";
			break;

		case Token::Type::INT:
			name = "Integer";
			break;

		case Token::Type::INT64:
			name = "Int64";
			break;

		case Token::Type::INTPTR:
			name = "NativeInt";
			break;

		case Token::Type::STRING:
			name = "PAnsiChar";
			break;

		case Token::Type::UCHAR:
			name = "Byte";
			break;

		case Token::Type::UINT:
			name = "Cardinal";
			break;

		case Token::Type::UINT64:
			name = "QWord";
			break;

		case Token::Type::IDENTIFIER:
			name = (typeRef.type == BaseType::Type::INTERFACE ? prefix : "") + typeRef.token.text;
			break;

		default:
			name = typeRef.token.text;
			break;
	}

	if (typeRef.isPointer)
	{
		if (name == "void")
			return "Pointer";

		if (pointerTypes.find(name) == pointerTypes.end())
			pointerTypes.insert(name);

		name += "Ptr";
	}

	return name;
}

string PascalGenerator::escapeName(string name)
{
	//// TODO: Create a table of keywords.

	if (name == "file" || name == "function" || name == "procedure" || name == "record" || name == "set" ||
		name == "to" || name == "type")
	{
		name += "_";
	}

	return name;
}

void PascalGenerator::insertFile(const string& filename)
{
	if (filename.empty())
		return;

	FILE* in = fopen(filename.c_str(), "r");

	if (!in)
		throw runtime_error(string("Error opening input file '") + filename + "'.");

	char buffer[1024];
	size_t count;

	while ((count = fread(buffer, 1, sizeof(buffer), in)) > 0)
		fwrite(buffer, 1, count, out);

	fclose(in);
}


//--------------------------------------


JnaGenerator::JnaGenerator(
	const string& filename, const string& prefix, Parser* parser, const string& className, const string& exceptionClass)
	: FileGenerator(filename, prefix),
	  parser(parser),
	  className(className),
	  exceptionClass(exceptionClass)
{
}

void JnaGenerator::generate()
{
	fprintf(out, "// %s\n\n", AUTOGEN_MSG);

	string::size_type lastDot = className.rfind('.');
	string::size_type classStart;

	if (lastDot != string::npos)
	{
		fprintf(out, "package %s;\n", className.substr(0, lastDot).c_str());
		fprintf(out, "\n");
		fprintf(out, "\n");

		classStart = lastDot + 1;
	}
	else
		classStart = 0;

	fprintf(out, "public interface %s extends com.sun.jna.Library\n", className.substr(classStart).c_str());
	fprintf(out, "{\n");

	for (const auto& interface : parser->interfaces)
	{
		if (interface.get() != parser->interfaces.front().get())
			fprintf(out, "\n");

		fprintf(out, "\tpublic static interface %s%sIntf", prefix.c_str(), escapeName(interface->name).c_str());

		if (interface->super)
		{
			fprintf(out, " extends %s%sIntf", prefix.c_str(), escapeName(interface->super->name).c_str());
		}

		fprintf(out, "\n");
		fprintf(out, "\t{\n");

		for (const auto& constant : interface->constants)
		{
			fprintf(out, "\t\tpublic static %s %s = %s;\n", convertType(constant->typeRef, false).c_str(),
				constant->name.c_str(), constant->expr->generate(Language::JAVA, prefix).c_str());
		}

		if (!interface->constants.empty())
			fprintf(out, "\n");

		for (const auto& method : interface->methods)
		{
			fprintf(out, "\t\tpublic %s %s(", convertType(method->returnTypeRef, true).c_str(),
				escapeName(method->name).c_str());

			for (const auto& parameter : method->parameters)
			{
				if (&parameter != &method->parameters.front())
					fprintf(out, ", ");

				fprintf(
					out, "%s %s", convertType(parameter->typeRef, false).c_str(), escapeName(parameter->name).c_str());
			}

			bool mayThrow = !method->parameters.empty() && parser->exceptionInterface &&
				method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name &&
				!exceptionClass.empty();

			fprintf(out, ")");

			if (mayThrow)
				fprintf(out, " throws %s", exceptionClass.c_str());

			fprintf(out, ";\n");
		}

		fprintf(out, "\t}\n");
	}

	for (const auto& interface : parser->interfaces)
	{
		fprintf(out, "\n");
		fprintf(out, "\tpublic static class %s%s extends ", prefix.c_str(), escapeName(interface->name).c_str());

		if (interface->super)
			fprintf(out, "%s%s", prefix.c_str(), escapeName(interface->super->name).c_str());
		else
			fprintf(out, "com.sun.jna.Structure");

		fprintf(out, " implements %s%sIntf\n", prefix.c_str(), escapeName(interface->name).c_str());
		fprintf(out, "\t{\n");

		fprintf(out,
			"\t\tpublic static class ByReference extends %s%s implements "
			"com.sun.jna.Structure.ByReference\n",
			prefix.c_str(), escapeName(interface->name).c_str());
		fprintf(out, "\t\t{\n");
		fprintf(out, "\t\t}\n\n");

		fprintf(out, "\t\tpublic static class ByValue extends %s%s implements com.sun.jna.Structure.ByValue\n",
			prefix.c_str(), escapeName(interface->name).c_str());
		fprintf(out, "\t\t{\n");
		fprintf(out, "\t\t}\n\n");

		const auto methods = collectInterfaceMethods(interface.get());

		for (const auto& method : methods)
		{
			fprintf(out, "\t\tpublic %s %s(", convertType(method->returnTypeRef, true).c_str(),
				escapeName(method->name).c_str());

			for (const auto& parameter : method->parameters)
			{
				if (&parameter != &method->parameters.front())
					fprintf(out, ", ");

				fprintf(
					out, "%s %s", convertType(parameter->typeRef, false).c_str(), escapeName(parameter->name).c_str());
			}

			bool mayThrow = !method->parameters.empty() && parser->exceptionInterface &&
				method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name &&
				!exceptionClass.empty();

			fprintf(out, ")");

			if (mayThrow)
				fprintf(out, " throws %s", exceptionClass.c_str());

			fprintf(out, "\n");
			fprintf(out, "\t\t{\n");

			bool hasReturn = method->returnTypeRef.token.type != Token::Type::VOID || method->returnTypeRef.isPointer;

			if (hasReturn)
				fprintf(out, "\t\t\t%s result;\n", convertType(method->returnTypeRef, true).c_str());

			string statusName;

			if (!method->parameters.empty() && parser->exceptionInterface &&
				method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name)
			{
				statusName = method->parameters.front()->name;
			}

			fprintf(out, "\t\t\ttry\n");
			fprintf(out, "\t\t\t{\n");

			if (hasReturn)
				fprintf(out, "\t\t\t\tresult = ");

			fprintf(out, "\t\t\t\tvTable.%s.invoke(this", escapeName(method->name).c_str());

			for (const auto& parameter : method->parameters)
				fprintf(out, ", %s", escapeName(parameter->name).c_str());

			fprintf(out, ");\n");

			if (!statusName.empty())
				fprintf(out, "\t\t\t\tStatusType::checkException(%s);\n", statusName.c_str());

			fprintf(out, "\t\t\t}\n");
			fprintf(out, "\t\t\tfinally\n");
			fprintf(out, "\t\t\t{\n");

			if (!statusName.empty())
				fprintf(out, "\t\t\t\tStatusType::clearException(%s);\n", statusName.c_str());

			fprintf(out, "\t\t\t}\n");

			if (hasReturn)
				fprintf(out, "\t\t\treturn result;\n");

			fprintf(out, "\t\t}\n");
		}

		if (!methods.empty())
			fprintf(out, "\n");

		fprintf(out, "\t\tpublic static class VTable extends com.sun.jna.Structure\n");
		fprintf(out, "\t\t{\n");
		fprintf(out, "\t\t\tpublic int version;\n\n");

		for (const auto& method : interface->methods)
		{
			fprintf(out, "\t\t\tpublic static interface %s extends com.sun.jna.Callback\n",
				escapeName(method->name).c_str());
			fprintf(out, "\t\t\t{\n");

			const string selfPrefix = method->isConst ? "" : className.substr(classStart) + ".";

			fprintf(out, "\t\t\t\t%s invoke(%s%s self", convertType(method->returnTypeRef, true).c_str(),
				selfPrefix.c_str(), escapeName(interface->name).c_str());

			for (const auto& parameter : method->parameters)
			{
				fprintf(out, ", %s %s", convertType(parameter->typeRef, false).c_str(),
					escapeName(parameter->name).c_str());
			}

			fprintf(out, ");\n");
			fprintf(out, "\t\t\t}\n\n");

			fprintf(out, "\t\t\tpublic %s %s;\n", escapeName(method->name).c_str(), escapeName(method->name).c_str());
		}

		fprintf(out, "\t\t}\n");
		fprintf(out, "\t}\n");
	}

	fprintf(out, "}\n");
}

string JnaGenerator::convertType(const TypeRef& typeRef, bool forReturn)
{
	string name;

	switch (typeRef.token.type)
	{
		case Token::Type::BOOLEAN:
			name = "boolean";
			break;

		case Token::Type::INT:
			name = "int";
			break;

		case Token::Type::INT64:
			name = "long";
			break;

		case Token::Type::INTPTR:
			name = "com.sun.jna.Pointer";
			break;

		case Token::Type::STRING:
			if (typeRef.isConst)
				name = "String";
			else
				name = "com.sun.jna.Pointer";
			break;

		case Token::Type::UCHAR:
			name = "byte";
			break;

		case Token::Type::UINT:
			name = "int";
			break;

		case Token::Type::UINT64:
			name = "long";
			break;

		default:
			if (typeRef.type == BaseType::Type::INTERFACE && typeRef.token.type == Token::Type::IDENTIFIER)
			{
				name = prefix;
			}

			name += typeRef.token.text;
			break;
	}

	if (typeRef.isPointer)
	{
		if (forReturn || name == "void")
			return "com.sun.jna.Pointer";
		else
			name += "[]";
	}

	return name;
}

string JnaGenerator::literalForError(const TypeRef& typeRef)
{
	if (typeRef.isPointer)
		return "null";

	switch (typeRef.token.type)
	{
		case Token::Type::BOOLEAN:
			return "false";

		case Token::Type::INT:
		case Token::Type::INT64:
		case Token::Type::UINT:
		case Token::Type::UINT64:
			return "0";

		case Token::Type::UCHAR:
			return "(byte) 0";

		default:
			return "null";
	}
}

string JnaGenerator::escapeName(const string& name)
{
	//// TODO: Create a table of keywords.
	return name;
}


//--------------------------------------


JsonGenerator::JsonGenerator(const string& filename, Parser* parser)
	: FileGenerator(filename, ""),
	  parser(parser)
{
}

void JsonGenerator::generate()
{
	fprintf(out, "{\n");
	fprintf(out, "\t\"library\":\n");
	fprintf(out, "\t{\n");

	fprintf(out, "\t\t\"interfaces\":\n");
	fprintf(out, "\t\t[\n");

	for (const auto& interface : parser->interfaces)
	{
		fprintf(out, "\t\t\t{\n");
		fprintf(out, "\t\t\t\t\"name\": \"%s\",\n", interface->name.c_str());
		fprintf(out, "\t\t\t\t\"version\": %d,\n", interface->version);

		if (interface->super)
			fprintf(out, "\t\t\t\t\"extends\": \"%s\",\n", interface->super->name.c_str());

		fprintf(out, "\t\t\t\t\"constants\":\n");
		fprintf(out, "\t\t\t\t[\n");

		for (const auto& constant : interface->constants)
		{
			fprintf(out, "\t\t\t\t\t{\n");
			fprintf(out, "\t\t\t\t\t\t\"name\": \"%s\",\n", constant->name.c_str());
			fprintf(out, "\t\t\t\t\t\t\"type\": %s,\n", convertType(constant->typeRef).c_str());
			fprintf(out, "\t\t\t\t\t\t\"expr\": %s\n", constant->expr->generate(Language::JSON, prefix).c_str());

			fprintf(out, "\t\t\t\t\t}");

			if (&constant != &interface->constants.back())
				fprintf(out, ",");

			fprintf(out, "\n");
		}

		fprintf(out, "\t\t\t\t],\n");

		fprintf(out, "\t\t\t\t\"methods\":\n");
		fprintf(out, "\t\t\t\t[\n");

		for (const auto& method : interface->methods)
		{
			fprintf(out, "\t\t\t\t\t{\n");
			fprintf(out, "\t\t\t\t\t\t\"name\": \"%s\",\n", method->name.c_str());
			fprintf(out, "\t\t\t\t\t\t\"version\": %d,\n", method->version);
			fprintf(out, "\t\t\t\t\t\t\"returnType\": %s,\n", convertType(method->returnTypeRef).c_str());

			bool mayThrow = !method->parameters.empty() && parser->exceptionInterface &&
				method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name;

			fprintf(out, "\t\t\t\t\t\t\"mayThrow\": %s,\n", (mayThrow ? "true" : "false"));

			if (method->notImplementedExpr)
			{
				fprintf(out, "\t\t\t\t\t\t\"notImplementedExpr\": %s,\n",
					method->notImplementedExpr->generate(Language::JSON, prefix).c_str());
			}

			fprintf(out, "\t\t\t\t\t\t\"parameters\":\n");
			fprintf(out, "\t\t\t\t\t\t[\n");

			for (const auto& parameter : method->parameters)
			{
				fprintf(out, "\t\t\t\t\t\t\t{\n");
				fprintf(out, "\t\t\t\t\t\t\t\t\"name\": \"%s\",\n", parameter->name.c_str());
				fprintf(out, "\t\t\t\t\t\t\t\t\"type\": %s\n", convertType(parameter->typeRef).c_str());
				fprintf(out, "\t\t\t\t\t\t\t}");

				if (&parameter != &method->parameters.back())
					fprintf(out, ", ");

				fprintf(out, "\n");
			}

			fprintf(out, "\t\t\t\t\t\t]\n");
			fprintf(out, "\t\t\t\t\t}");

			if (&method != &interface->methods.back())
				fprintf(out, ",");

			fprintf(out, "\n");
		}

		fprintf(out, "\t\t\t\t]\n");

		fprintf(out, "\t\t\t}");

		if (interface.get() != parser->interfaces.back().get())
			fprintf(out, ",");

		fprintf(out, "\n");
	}

	fprintf(out, "\t\t]\n");
	fprintf(out, "\t}\n");
	fprintf(out, "}\n");
}

string JsonGenerator::convertType(const TypeRef& typeRef)
{
	return "{ \"name\": \"" + typeRef.token.text + "\", \"isPointer\": " + (typeRef.isPointer ? "true" : "false") +
		", \"isConst\": " + (typeRef.isConst ? "true" : "false") + " }";
}
