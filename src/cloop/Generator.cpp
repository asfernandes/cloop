/*
 *  The contents of this file are subject to the Initial
 *  Developer's Public License Version 1.0 (the "License");
 *  you may not use this file except in compliance with the
 *  License. You may obtain a copy of the License at
 *  http://www.ibphoenix.com/main.nfs?a=ibphoenix&page=ibp_idpl.
 *
 *  Software distributed under the License is distributed AS IS,
 *  WITHOUT WARRANTY OF ANY KIND, either express or implied.
 *  See the License for the specific language governing rights
 *  and limitations under the License.
 *
 *  The Original Code was created by Adriano dos Santos Fernandes.
 *
 *  Copyright (c) 2014 Adriano dos Santos Fernandes <adrianosf at gmail.com>
 *  and all contributors signed below.
 *
 *  All Rights Reserved.
 *  Contributor(s): ______________________________________.
 */

#include "Generator.h"
#include "Expr.h"
#include <deque>
#include <set>
#include <stdexcept>
#include <string>
#include <vector>
#include <inttypes.h>

using std::deque;
using std::runtime_error;
using std::set;
using std::string;
using std::vector;


//--------------------------------------


const char* const Generator::AUTOGEN_MSG =
	"This file was autogenerated by cloop - Cross Language Object Oriented Programming";


//--------------------------------------


FileGenerator::FileGenerator(const string& filename, const string& prefix)
	: prefix(prefix)
{
	out = fopen(filename.c_str(), "w+");

	if (!out)
		throw runtime_error(string("Error creating output file '") + filename + "'.");
}

FileGenerator::~FileGenerator()
{
	fclose(out);
}


//--------------------------------------


CBasedGenerator::CBasedGenerator(const string& filename, const string& prefix, bool cPlusPlus)
	: FileGenerator(filename, prefix),
	  cPlusPlus(cPlusPlus)
{
}

string CBasedGenerator::convertType(const TypeRef& typeRef)
{
	string ret(typeRef.isConst ? "const " : "");

	switch (typeRef.token.type)
	{
		case Token::TYPE_BOOLEAN:
			ret += "FB_BOOLEAN";	// seems to be more portable than bool, specially thinking on pointers
			break;

		case Token::TYPE_INT:
			ret += "int";
			break;

		case Token::TYPE_INT64:
			ret += "ISC_INT64";		//int64_t
			break;

		case Token::TYPE_INTPTR:
			ret += "intptr_t";
			break;

		case Token::TYPE_STRING:
			ret += "char*";
			break;

		case Token::TYPE_UCHAR:
			ret += "unsigned char";
			break;

		case Token::TYPE_UINT:
			ret += "unsigned";
			break;

		case Token::TYPE_UINT64:
			ret += "ISC_UINT64";	//uint64_t
			break;

		case Token::TYPE_IDENTIFIER:
			ret += string(cPlusPlus || typeRef.type == BaseType::TYPE_TYPEDEF ? "" : "struct ") +
				(typeRef.type == BaseType::TYPE_INTERFACE ? prefix : "") + typeRef.token.text;

			if (typeRef.type == BaseType::TYPE_INTERFACE)
				ret += "*";
			break;

		default:
			ret += typeRef.token.text;
			break;
	}

	if (typeRef.isPointer)
		ret += "*";

	return ret;
}


//--------------------------------------


CppGenerator::CppGenerator(const string& filename, const string& prefix, Parser* parser,
		const string& headerGuard, const string& nameSpace)
	: CBasedGenerator(filename, prefix, true),
	  parser(parser),
	  headerGuard(headerGuard),
	  nameSpace(nameSpace)
{
}

void CppGenerator::generate()
{
	fprintf(out, "// %s\n\n", AUTOGEN_MSG);

	fprintf(out, "#ifndef %s\n", headerGuard.c_str());
	fprintf(out, "#define %s\n\n", headerGuard.c_str());
	///fprintf(out, "#include <stdint.h>\n\n");

	fprintf(out, "#ifndef CLOOP_CARG\n");
	fprintf(out, "#define CLOOP_CARG\n");
	fprintf(out, "#endif\n\n\n");

	fprintf(out, "namespace %s\n", nameSpace.c_str());
	fprintf(out, "{\n");
	fprintf(out, "\tclass DoNotInherit\n");
	fprintf(out, "\t{\n");
	fprintf(out, "\t};\n");
	fprintf(out, "\n");
	fprintf(out, "\ttemplate <typename T>\n");
	fprintf(out, "\tclass Inherit : public T\n");
	fprintf(out, "\t{\n");
	fprintf(out, "\tpublic:\n");
	fprintf(out, "\t\tInherit(DoNotInherit = DoNotInherit())\n");
	fprintf(out, "\t\t\t: T(DoNotInherit())\n");
	fprintf(out, "\t\t{\n");
	fprintf(out, "\t\t}\n");
	fprintf(out, "\t};\n");
	fprintf(out, "\n");

	fprintf(out, "\t// Forward interfaces declarations\n\n");

	for (vector<Interface*>::iterator i = parser->interfaces.begin();
		 i != parser->interfaces.end();
		 ++i)
	{
		Interface* interface = *i;

		fprintf(out, "\tclass %s%s;\n", prefix.c_str(), interface->name.c_str());
	}

	fprintf(out, "\n");
	fprintf(out, "\t// Interfaces declarations\n\n");

	for (vector<Interface*>::iterator i = parser->interfaces.begin();
		 i != parser->interfaces.end();
		 ++i)
	{
		Interface* interface = *i;

		deque<Method*> methods;

		for (Interface* p = interface; p; p = p->super)
			methods.insert(methods.begin(), p->methods.begin(), p->methods.end());

		if (!interface->super)
			fprintf(out, "\tclass %s%s\n", prefix.c_str(), interface->name.c_str());
		else
		{
			fprintf(out, "\tclass %s%s : public %s%s\n",
				prefix.c_str(), interface->name.c_str(),
				prefix.c_str(), interface->super->name.c_str());
		}

		fprintf(out, "\t{\n");
		fprintf(out, "\tpublic:\n");

		if (!interface->super)
		{
			fprintf(out, "\t\tstruct VTable\n");
			fprintf(out, "\t\t{\n");
			fprintf(out, "\t\t\tvoid* cloopDummy[%d];\n", DUMMY_VTABLE);
			fprintf(out, "\t\t\tuintptr_t version;\n");
		}
		else
		{
			fprintf(out, "\t\tstruct VTable : public %s%s::VTable\n",
				prefix.c_str(), interface->super->name.c_str());
			fprintf(out, "\t\t{\n");
		}

		for (vector<Method*>::iterator j = interface->methods.begin();
			 j != interface->methods.end();
			 ++j)
		{
			Method* method = *j;

			fprintf(out, "\t\t\t%s (CLOOP_CARG *%s)(%s%s%s* self",
				convertType(method->returnTypeRef).c_str(),
				method->name.c_str(),
				(method->isConst ? "const " : ""),
				prefix.c_str(),
				interface->name.c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				fprintf(out, ", %s %s",
					convertType(parameter->typeRef).c_str(), parameter->name.c_str());
			}

			fprintf(out, ") throw();\n");
		}

		fprintf(out, "\t\t};\n");
		fprintf(out, "\n");

		if (!interface->super)
		{
			fprintf(out, "\t\tvoid* cloopDummy[%d];\n", DUMMY_INSTANCE);
			fprintf(out, "\t\tVTable* cloopVTable;\n");
			fprintf(out, "\n");
		}

		fprintf(out, "\tprotected:\n");
		fprintf(out, "\t\t%s%s(DoNotInherit)\n", prefix.c_str(), interface->name.c_str());

		if (interface->super)
		{
			fprintf(out, "\t\t\t: %s%s(DoNotInherit())\n",
				prefix.c_str(), interface->super->name.c_str());
		}

		fprintf(out, "\t\t{\n");
		fprintf(out, "\t\t}\n");
		fprintf(out, "\n");
		fprintf(out, "\t\t~%s%s()\n", prefix.c_str(), interface->name.c_str());
		fprintf(out, "\t\t{\n");
		fprintf(out, "\t\t}\n");
		fprintf(out, "\n");

		fprintf(out, "\tpublic:\n");
		fprintf(out, "\t\tstatic const unsigned VERSION = %u;\n", interface->version);

		if (!interface->constants.empty())
			fprintf(out, "\n");

		for (vector<Constant*>::iterator j = interface->constants.begin();
			 j != interface->constants.end();
			 ++j)
		{
			Constant* constant = *j;

			fprintf(out, "\t\tstatic const %s %s = %s;\n",
				convertType(constant->typeRef).c_str(),
				constant->name.c_str(),
				constant->expr->generate(LANGUAGE_CPP, prefix).c_str());
		}

		for (vector<Method*>::iterator j = interface->methods.begin();
			 j != interface->methods.end();
			 ++j)
		{
			Method* method = *j;

			fprintf(out, "\n\t\t");

			string statusName;

			if (!method->parameters.empty() &&
				parser->exceptionInterface &&
				method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name)
			{
				statusName = method->parameters.front()->name;
				fprintf(out, "template <typename StatusType> ");
			}

			fprintf(out, "%s %s(",
				convertType(method->returnTypeRef).c_str(), method->name.c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				if (k != method->parameters.begin())
					fprintf(out, ", ");

				if (k == method->parameters.begin() && !statusName.empty())
					fprintf(out, "StatusType* %s", parameter->name.c_str());
				else
				{
					fprintf(out, "%s %s",
						convertType(parameter->typeRef).c_str(), parameter->name.c_str());
				}
			}

			fprintf(out, ")%s\n", (method->isConst ? " const" : ""));
			fprintf(out, "\t\t{\n");

			if (method->version - (interface->super ? interface->super->version : 0) != 1)
			{
				fprintf(out, "\t\t\tif (cloopVTable->version < %d)\n", method->version);
				fprintf(out, "\t\t\t{\n");

				if (!statusName.empty())
				{
					fprintf(out,
						"\t\t\t\tStatusType::setVersionError(%s, \"%s%s\", cloopVTable->version, %d);\n",
						statusName.c_str(),
						prefix.c_str(),
						interface->name.c_str(),
						method->version);

					fprintf(out, "\t\t\t\tStatusType::checkException(%s);\n", statusName.c_str());
				}

				fprintf(out, "\t\t\t\treturn");

				if (method->returnTypeRef.token.type != Token::TYPE_VOID ||
					method->returnTypeRef.isPointer)
				{
					fprintf(out, " %s",
						(method->notImplementedExpr ?
							method->notImplementedExpr->generate(LANGUAGE_CPP, prefix).c_str() :
							"0"));
				}

				fprintf(out, ";\n");
				fprintf(out, "\t\t\t}\n");
			}

			if (!statusName.empty())
			{
				fprintf(out, "\t\t\t");

				fprintf(out, "StatusType::clearException(%s)", statusName.c_str());

				fprintf(out, ";\n");
			}

			fprintf(out, "\t\t\t");

			if (method->returnTypeRef.token.type != Token::TYPE_VOID ||
				method->returnTypeRef.isPointer)
			{
				fprintf(out, "%s ret = ", convertType(method->returnTypeRef).c_str());
			}

			fprintf(out, "static_cast<VTable*>(this->cloopVTable)->%s(this",
				method->name.c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;
				fprintf(out, ", %s", parameter->name.c_str());
			}

			fprintf(out, ")");
			fprintf(out, ";\n");

			if (!method->parameters.empty() &&
				parser->exceptionInterface &&
				method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name)
			{
				fprintf(out, "\t\t\tStatusType::checkException(%s);\n",
					method->parameters.front()->name.c_str());
			}

			if (method->returnTypeRef.token.type != Token::TYPE_VOID ||
				method->returnTypeRef.isPointer)
			{
				fprintf(out, "\t\t\treturn ret;\n");
			}

			fprintf(out, "\t\t}\n");
		}

		fprintf(out, "\t};\n\n");
	}

	fprintf(out, "\t// Interfaces implementations\n");

	for (vector<Interface*>::iterator i = parser->interfaces.begin();
		 i != parser->interfaces.end();
		 ++i)
	{
		Interface* interface = *i;

		deque<Method*> methods;

		for (Interface* p = interface; p; p = p->super)
			methods.insert(methods.begin(), p->methods.begin(), p->methods.end());

		fprintf(out, "\n");
		fprintf(out, "\ttemplate <typename Name, typename StatusType, typename Base>\n");
		fprintf(out, "\tclass %s%sBaseImpl : public Base\n",
			prefix.c_str(), interface->name.c_str());
		fprintf(out, "\t{\n");
		fprintf(out, "\tpublic:\n");
		fprintf(out, "\t\ttypedef %s%s Declaration;\n", prefix.c_str(), interface->name.c_str());
		fprintf(out, "\n");
		fprintf(out, "\t\t%s%sBaseImpl(DoNotInherit = DoNotInherit())\n",
			prefix.c_str(), interface->name.c_str());
		fprintf(out, "\t\t{\n");
		fprintf(out, "\t\t\tstatic struct VTableImpl : Base::VTable\n");
		fprintf(out, "\t\t\t{\n");
		fprintf(out, "\t\t\t\tVTableImpl()\n");
		fprintf(out, "\t\t\t\t{\n");
		fprintf(out, "\t\t\t\t\tthis->version = Base::VERSION;\n");

		for (deque<Method*>::iterator j = methods.begin(); j != methods.end(); ++j)
		{
			Method* method = *j;

			fprintf(out, "\t\t\t\t\tthis->%s = &Name::cloop%sDispatcher;\n",
				method->name.c_str(), method->name.c_str());
		}

		fprintf(out, "\t\t\t\t}\n");
		fprintf(out, "\t\t\t} vTable;\n");
		fprintf(out, "\n");

		fprintf(out, "\t\t\tthis->cloopVTable = &vTable;\n");
		fprintf(out, "\t\t}\n");

		// We generate all bases dispatchers so indirect overrides work. At the same time, we
		// inherit from all bases impls, so pure virtual methods are introduced and required to
		// be overriden in the user's implementation.

		for (Interface* p = interface; p; p = p->super)
		{
			for (vector<Method*>::iterator j = p->methods.begin(); j != p->methods.end(); ++j)
			{
				Method* method = *j;

				fprintf(out, "\n");
				fprintf(out, "\t\tstatic %s CLOOP_CARG cloop%sDispatcher(%s%s%s* self",
					convertType(method->returnTypeRef).c_str(),
					method->name.c_str(),
					(method->isConst ? "const " : ""),
					prefix.c_str(),
					p->name.c_str());

				for (vector<Parameter*>::iterator k = method->parameters.begin();
					 k != method->parameters.end();
					 ++k)
				{
					Parameter* parameter = *k;

					fprintf(out, ", %s %s",
						convertType(parameter->typeRef).c_str(), parameter->name.c_str());
				}

				Parameter* exceptionParameter =
					(!method->parameters.empty() &&
					 parser->exceptionInterface &&
					 method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name
					) ? method->parameters.front() : NULL;

				fprintf(out, ") throw()\n");
				fprintf(out, "\t\t{\n");

				if (exceptionParameter)
				{
					fprintf(out, "\t\t\tStatusType %s2(%s);\n",
						exceptionParameter->name.c_str(),
						exceptionParameter->name.c_str());
					fprintf(out, "\n");
				}

				fprintf(out, "\t\t\ttry\n");
				fprintf(out, "\t\t\t{\n");

				fprintf(out, "\t\t\t\t");

				if (method->returnTypeRef.token.type != Token::TYPE_VOID ||
					method->returnTypeRef.isPointer)
				{
					fprintf(out, "return ");
				}

				fprintf(out, "static_cast<%sName*>(self)->Name::%s(",
					(method->isConst ? "const " : ""),
					method->name.c_str());

				for (vector<Parameter*>::iterator k = method->parameters.begin();
					 k != method->parameters.end();
					 ++k)
				{
					Parameter* parameter = *k;

					if (k != method->parameters.begin())
						fprintf(out, ", ");

					if (parameter == exceptionParameter)
						fprintf(out, "&%s2", parameter->name.c_str());
					else
						fprintf(out, "%s", parameter->name.c_str());
				}

				fprintf(out, ");\n");

				fprintf(out, "\t\t\t}\n");
				fprintf(out, "\t\t\tcatch (...)\n");
				fprintf(out, "\t\t\t{\n");
				fprintf(out, "\t\t\t\tStatusType::catchException(%s);\n",
					(exceptionParameter ? ("&" + exceptionParameter->name + "2").c_str() : "0"));

				if (method->returnTypeRef.token.type != Token::TYPE_VOID ||
					method->returnTypeRef.isPointer)
				{
					const char* ret = "\t\t\t\treturn";
					if (method->onErrorFunction.length())
					{
						fprintf(out, "%s %s();\n",
							ret, method->onErrorFunction.c_str());
					}
					else
					{
						fprintf(out, "%s static_cast<%s>(0);\n",
							ret, convertType(method->returnTypeRef).c_str());
					}
				}

				fprintf(out, "\t\t\t}\n");

				fprintf(out, "\t\t}\n");
			}
		}

		fprintf(out, "\t};\n\n");

		if (!interface->super)
		{
			fprintf(out, "\ttemplate <typename Name, typename StatusType, typename Base = Inherit<%s%s> >\n",
				prefix.c_str(), interface->name.c_str());
		}
		else
		{
			string base;
			unsigned baseCount = 0;

			for (Interface* p = interface->super; p; p = p->super)
			{
				base += prefix + p->name + "Impl<Name, StatusType, Inherit<";
				++baseCount;
			}

			base += prefix.c_str() + interface->name;

			while (baseCount-- > 0)
				base += "> > ";

			fprintf(out, "\ttemplate <typename Name, typename StatusType, typename Base = %s>\n", base.c_str());
		}

		fprintf(out, "\tclass %s%sImpl : public %s%sBaseImpl<Name, StatusType, Base>\n",
			prefix.c_str(), interface->name.c_str(), prefix.c_str(), interface->name.c_str());
		fprintf(out, "\t{\n");
		fprintf(out, "\tprotected:\n");
		fprintf(out, "\t\t%s%sImpl(DoNotInherit = DoNotInherit())\n",
			prefix.c_str(), interface->name.c_str());
		fprintf(out, "\t\t{\n");
		fprintf(out, "\t\t}\n");
		fprintf(out, "\n");
		fprintf(out, "\tpublic:\n");
		fprintf(out, "\t\tvirtual ~%s%sImpl()\n", prefix.c_str(), interface->name.c_str());
		fprintf(out, "\t\t{\n");
		fprintf(out, "\t\t}\n");
		fprintf(out, "\n");

		for (vector<Method*>::iterator j = interface->methods.begin();
			 j != interface->methods.end();
			 ++j)
		{
			Method* method = *j;

			Parameter* exceptionParameter =
				(!method->parameters.empty() &&
				 parser->exceptionInterface &&
				 method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name
				) ? method->parameters.front() : NULL;

			fprintf(out, "\t\tvirtual %s %s(",
				convertType(method->returnTypeRef).c_str(), method->name.c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				if (k != method->parameters.begin())
					fprintf(out, ", ");

				if (parameter == exceptionParameter)
					fprintf(out, "StatusType* %s", parameter->name.c_str());
				else
				{
					fprintf(out, "%s %s",
						convertType(parameter->typeRef).c_str(), parameter->name.c_str());
				}
			}

			fprintf(out, ")%s = 0;\n", (method->isConst ? " const" : ""));
		}

		fprintf(out, "\t};\n");
	}

	fprintf(out, "};\n\n");
	fprintf(out, "\n");

	fprintf(out, "#endif\t// %s\n", headerGuard.c_str());
}


//--------------------------------------


CHeaderGenerator::CHeaderGenerator(const string& filename, const string& prefix, Parser* parser,
		const string& headerGuard)
	: CBasedGenerator(filename, prefix, false),
	  parser(parser),
	  headerGuard(headerGuard)
{
}

void CHeaderGenerator::generate()
{
	fprintf(out, "/* %s */\n\n", AUTOGEN_MSG);

	fprintf(out, "#ifndef %s\n", headerGuard.c_str());
	fprintf(out, "#define %s\n\n", headerGuard.c_str());
	fprintf(out, "#include <stdint.h>\n\n");

	fprintf(out, "#ifndef CLOOP_EXTERN_C\n");
	fprintf(out, "#ifdef __cplusplus\n");
	fprintf(out, "#define CLOOP_EXTERN_C extern \"C\"\n");
	fprintf(out, "#else\n");
	fprintf(out, "#define CLOOP_EXTERN_C\n");
	fprintf(out, "#endif\n");
	fprintf(out, "#endif\n\n\n");

	for (vector<Interface*>::iterator i = parser->interfaces.begin();
		 i != parser->interfaces.end();
		 ++i)
	{
		Interface* interface = *i;

		fprintf(out, "struct %s%s;\n", prefix.c_str(), interface->name.c_str());
	}

	fprintf(out, "\n\n");

	for (vector<Interface*>::iterator i = parser->interfaces.begin();
		 i != parser->interfaces.end();
		 ++i)
	{
		Interface* interface = *i;

		deque<Method*> methods;

		for (Interface* p = interface; p; p = p->super)
			methods.insert(methods.begin(), p->methods.begin(), p->methods.end());

		fprintf(out, "#define %s%s_VERSION %d\n\n",
			prefix.c_str(), interface->name.c_str(), (int) methods.size());

		for (vector<Constant*>::iterator j = interface->constants.begin();
			 j != interface->constants.end();
			 ++j)
		{
			Constant* constant = *j;

			fprintf(out, "#define %s%s_%s ((%s) (%s))\n",
				prefix.c_str(),
				interface->name.c_str(),
				constant->name.c_str(),
				convertType(constant->typeRef).c_str(),
				constant->expr->generate(LANGUAGE_C, prefix).c_str());
		}

		if (!interface->constants.empty())
			fprintf(out, "\n");

		fprintf(out, "struct %s%s;\n\n", prefix.c_str(), interface->name.c_str());

		fprintf(out, "struct %s%sVTable\n", prefix.c_str(), interface->name.c_str());
		fprintf(out, "{\n");
		fprintf(out, "\tvoid* cloopDummy[%d];\n", DUMMY_VTABLE);
		fprintf(out, "\tuintptr_t version;\n");

		for (deque<Method*>::iterator j = methods.begin(); j != methods.end(); ++j)
		{
			Method* method = *j;

			fprintf(out, "\t%s (*%s)(%sstruct %s%s* self",
				convertType(method->returnTypeRef).c_str(),
				method->name.c_str(),
				(method->isConst ? "const " : ""),
				prefix.c_str(),
				interface->name.c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				fprintf(out, ", %s %s", convertType(parameter->typeRef).c_str(),
					parameter->name.c_str());
			}

			fprintf(out, ");\n");
		}

		fprintf(out, "};\n\n");

		fprintf(out, "struct %s%s\n", prefix.c_str(), interface->name.c_str());
		fprintf(out, "{\n");
		fprintf(out, "\tvoid* cloopDummy[%d];\n", DUMMY_INSTANCE);
		fprintf(out, "\tstruct %s%sVTable* vtable;\n", prefix.c_str(), interface->name.c_str());
		fprintf(out, "};\n\n");

		for (deque<Method*>::iterator j = methods.begin(); j != methods.end(); ++j)
		{
			Method* method = *j;

			fprintf(out, "CLOOP_EXTERN_C %s %s%s_%s(%sstruct %s%s* self",
				convertType(method->returnTypeRef).c_str(),
				prefix.c_str(),
				interface->name.c_str(),
				method->name.c_str(),
				(method->isConst ? "const " : ""),
				prefix.c_str(),
				interface->name.c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				fprintf(out, ", %s %s",
					convertType(parameter->typeRef).c_str(), parameter->name.c_str());
			}

			fprintf(out, ");\n");
		}

		fprintf(out, "\n");
	}

	fprintf(out, "\n");
	fprintf(out, "#endif\t// %s\n", headerGuard.c_str());
}


//--------------------------------------


CImplGenerator::CImplGenerator(const string& filename, const string& prefix, Parser* parser,
		const string& includeFilename)
	: CBasedGenerator(filename, prefix, false),
	  parser(parser),
	  includeFilename(includeFilename)
{
}

void CImplGenerator::generate()
{
	fprintf(out, "/* %s */\n\n", AUTOGEN_MSG);

	fprintf(out, "#include \"%s\"\n\n\n", includeFilename.c_str());

	for (vector<Interface*>::iterator i = parser->interfaces.begin();
		 i != parser->interfaces.end();
		 ++i)
	{
		Interface* interface = *i;

		deque<Method*> methods;

		for (Interface* p = interface; p; p = p->super)
			methods.insert(methods.begin(), p->methods.begin(), p->methods.end());

		for (deque<Method*>::iterator j = methods.begin(); j != methods.end(); ++j)
		{
			Method* method = *j;

			fprintf(out, "CLOOP_EXTERN_C %s %s%s_%s(%sstruct %s%s* self",
				convertType(method->returnTypeRef).c_str(),
				prefix.c_str(),
				interface->name.c_str(),
				method->name.c_str(),
				(method->isConst ? "const " : ""),
				prefix.c_str(),
				interface->name.c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				fprintf(out, ", %s %s",
					convertType(parameter->typeRef).c_str(), parameter->name.c_str());
			}

			fprintf(out, ")\n");
			fprintf(out, "{\n");
			fprintf(out, "\t");

			//// TODO: checkVersion

			if (method->returnTypeRef.token.type != Token::TYPE_VOID ||
				method->returnTypeRef.isPointer)
			{
				fprintf(out, "return ");
			}

			fprintf(out, "self->vtable->%s(self", method->name.c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;
				fprintf(out, ", %s", parameter->name.c_str());
			}

			fprintf(out, ");\n");
			fprintf(out, "}\n\n");
		}
	}
}


//--------------------------------------


PascalGenerator::PascalGenerator(const string& filename, const string& prefix, Parser* parser,
		const string& unitName, const std::string& additionalUses, const std::string& interfaceFile,
		const std::string& implementationFile, const std::string& exceptionClass, const std::string& functionsFile)
	: FileGenerator(filename, prefix),
	  parser(parser),
	  unitName(unitName),
	  additionalUses(additionalUses),
	  interfaceFile(interfaceFile),
	  implementationFile(implementationFile),
	  exceptionClass(exceptionClass),
	  functionsFile(functionsFile)
{
}

void PascalGenerator::generate()
{
	fprintf(out, "{ %s }\n\n", AUTOGEN_MSG);
	fprintf(out, "{ $DEFINE USEFBEXCEPTION}\n{ $DEFINE STATIC_LINK_TO_FIREBIRD_LIBRARY}\n\n");
	fprintf(out, "{$WARNINGS OFF}\n");

	fprintf(out, "{$IFDEF FPC}\n{$MODE DELPHI}\n{$ENDIF}\n\n");
	fprintf(out,"{$IFDEF MSWINDOWS}\n{$DEFINE WINDOWS}\n{$ENDIF}\n\n");

	fprintf(out, "unit %s;\n\n", unitName.c_str());
	fprintf(out, "interface\n\n");
	fprintf(out, "uses Classes");

	if (!additionalUses.empty())
		fprintf(out, ", %s", additionalUses.c_str());

	fprintf(out, ";\n\n");

	fprintf(out, "type\n");
	fprintf(out, "{$IFNDEF FPC}\n");
	fprintf(out, "\tQWord = UInt64;\n");
	fprintf(out, "{$ENDIF}\n\n");


	//Forward declarations for each interface 
	
	for (vector<Interface*>::iterator i = parser->interfaces.begin();
		 i != parser->interfaces.end();
		 ++i)
	{
		Interface* interface = *i;
		
		fprintf(out,"\t%s = ^T%s;\n",escapeName(interface->name,true).c_str(),escapeName(interface->name).c_str());
	}
	
	fprintf(out, "\n");
	
	insertFile(interfaceFile);

	// Pass at every type to fill pointerTypes. We need it in advance.

	for (vector<Interface*>::iterator i = parser->interfaces.begin();
		 i != parser->interfaces.end();
		 ++i)
	{
		Interface* interface = *i;
		
		//convert the type names and parameter names in each of the interface's method
		//and add to pointertypes if a pointer

		for (vector<Method*>::iterator j = interface->methods.begin();
			 j != interface->methods.end();
			 ++j)
		{
			Method* method = *j;

			convertType(method->returnTypeRef);

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;
				convertParameter(*parameter);
			}
		}
	}
	
	//output the pointer types

	for (set<string>::iterator i = pointerTypes.begin(); i != pointerTypes.end(); ++i)
	{
		string type = *i;
		if (type.compare("Byte") == 0) //special case - Delphi defines PByte as a type
		  fprintf(out, "\t%sPtr = P%s;\n", type.c_str(), type.c_str());
		else
		  fprintf(out, "\t%sPtr = ^%s;\n", type.c_str(), type.c_str());
	}

	if (!pointerTypes.empty())
		fprintf(out, "\n");
		
	
//now output type definitions for a pointer to each proc/function

	for (vector<Interface*>::iterator i = parser->interfaces.begin();
		 i != parser->interfaces.end();
		 ++i)
	{
		Interface* interface = *i;

		for (vector<Method*>::iterator j = interface->methods.begin();
			 j != interface->methods.end();
			 ++j)
		{
			Method* method = *j;

			bool isProcedure = method->returnTypeRef.token.type == Token::TYPE_VOID &&
				 !method->returnTypeRef.isPointer;

			fprintf(out, "\t%s_%sPtr = %s(this: %s",
				escapeName(interface->name, true).c_str(), escapeName(method->name).c_str(),
				(isProcedure ? "procedure" : "function"),
				escapeName(interface->name, true).c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;
				fprintf(out, "; %s", convertParameter(*parameter).c_str());
			}

			fprintf(out, ")");

			if (!isProcedure)
				fprintf(out, ": %s", convertType(method->returnTypeRef).c_str());

			fprintf(out, "; cdecl;\n");
		}
	}

	fprintf(out, "\n");
	
	for (vector<Interface*>::iterator i = parser->interfaces.begin();
		 i != parser->interfaces.end();
		 ++i)
	{
		Interface* interface = *i;

		//output vTable

		fprintf(out,"\tP%sVTable = ^%sVTable;\n",escapeName(interface->name).c_str(),escapeName(interface->name).c_str());
		fprintf(out, "\t%sVTable = record\n\t  NullPtr: pointer;\n\t  version: NativeInt;\n", escapeName(interface->name).c_str());
		
		outputAllVTableMethods(interface);
		
		fprintf(out, "\tend;\n\n");

		//forward reference needed to implementation class
		fprintf(out, "\t%sImpl = class;\n\n",
			escapeName(interface->name, true).c_str());
				

		//output interface declaration

		fprintf(out,"\tT%s = record\n",escapeName(interface->name).c_str());
		fprintf(out,"\tprivate\n");
		fprintf(out,"\t  FNullPtr: pointer;\n");
		fprintf(out,"\t  FvTable: P%sVTable;\n", escapeName(interface->name).c_str());
		fprintf(out,"\t  FObject: TObject; {Only valid when interface provided by an implementation class }\n");
        fprintf(out,"\t  function this: %s; inline;\n",escapeName(interface->name,true).c_str());

		fprintf(out,"\tpublic\n");
 		fprintf(out,"\t  function is%sImpl: boolean;\n",escapeName(interface->name, true).c_str());

		fprintf(out,"\t  function as%sImpl: %sImpl;\n",  escapeName(interface->name,true).c_str(),
 	                                                                escapeName(interface->name, true).c_str());	
	    fprintf(out,"\t  property vTable: P%sVTable read FvTable;\n", escapeName(interface->name).c_str());
	    
		fprintf(out,"\tpublic\n\t  {interface constants accessed using inline functions}\n");
		fprintf(out,"\t  function VERSION: NativeInt; inline;\n");
		outputAllConstInlineFunctionDeclarations(interface);
	    
		unsigned totalMethods = 0;

		for (Interface* p = interface; p; p = p->super)
			totalMethods += p->methods.size();
			
		if (totalMethods)
		{
		  fprintf(out, "\tpublic\n\t  {Firebird OOAPI methods}\n");
		
		  outputAllMethods(interface);
	    }
		
		fprintf(out,"\tend;\n\n");

		
		//output implementation class
		
		if (interface->super)
  		  fprintf(out, "\t%sImpl = class(%sImpl)\n",
			escapeName(interface->name, true).c_str(), escapeName(interface->super->name, true).c_str());
		else
  		  fprintf(out, "\t%sImpl = class\n",
			escapeName(interface->name, true).c_str());
			
		fprintf(out,"\tprivate\n");
			
		if (!interface->super) {
		  fprintf(out,"\t  FNullPtr: pointer;\n");
		  fprintf(out,"\t  FvTable: pointer;\n");
		  fprintf(out,"\t  FObject: TObject;\n");
		}
		fprintf(out,"\t  function getVTable: P%sVTable;\n", escapeName(interface->name).c_str());
		  
		unsigned version = 0;

		for (Interface* p = interface; p; p = p->super)
			version += p->methods.size();

		fprintf(out, "\tpublic\n\t  const VERSION = %d;\n", version);
		
		outputAllConstants(interface);
		
		fprintf(out,"\tpublic\n\t  constructor create;\n");
		fprintf(out,"\t  function as%s: %s;\n",escapeName(interface->name, true).c_str(),escapeName(interface->name, true).c_str());
		fprintf(out,"\t  class function is%sImpl(intf: %s): boolean;\n",escapeName(interface->name, true).c_str(),
		                                                                escapeName(interface->name, true).c_str());
  	      
  	    fprintf(out,"\t  property vTable: P%sVTable read getVTable;\n",escapeName(interface->name).c_str());
  	      

		if (interface->methods.size())
		{
		  fprintf(out,"\tpublic\n\t  {Firebird OOAPI interface}\n");

 	      for (vector<Method*>::iterator j = interface->methods.begin();
			 j != interface->methods.end();
			 ++j)
	      {
			Method* method = *j;
			bool isProcedure = method->returnTypeRef.token.type == Token::TYPE_VOID &&
				 !method->returnTypeRef.isPointer;

			fprintf(out, "\t  %s %s(",
				(isProcedure ? "procedure" : "function"),
				escapeName(method->name).c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				if (k != method->parameters.begin())
					fprintf(out, "; ");

				fprintf(out, "%s", convertParameter(*parameter).c_str());
			}

			fprintf(out, ")");

			if (!isProcedure)
				fprintf(out, ": %s", convertType(method->returnTypeRef).c_str());

			fprintf(out, "; virtual; abstract;\n");
		  }
		}

		fprintf(out, "\tend;\n\n");
	}
	fprintf(out,"\n");
	
	insertFile(functionsFile);
	
	fprintf(out, "implementation\n\n");
	
	fprintf(out,"resourcestring\n");
	fprintf(out,"\terrNotImplementationObject = 'interface is not an implementation of %s';\n\n","%s");
	
	//for each interface output the implementation methods

	for (vector<Interface*>::iterator i = parser->interfaces.begin();
		 i != parser->interfaces.end();
		 ++i)
	{
		Interface* interface = *i;
		
		//output the common methods and class operators
		
		                
		fprintf(out,"function T%s.this: %s;\n",
		                              escapeName(interface->name).c_str(),
		                              escapeName(interface->name,true).c_str());
	    fprintf(out,"begin\n");
	    fprintf(out,"  Result := %s(@FNullPtr);\n",escapeName(interface->name,true).c_str());
 	    fprintf(out,"end;\n\n");
		
 	    fprintf(out,"function T%s.is%sImpl: boolean;\n",escapeName(interface->name).c_str(),
 	                                                              escapeName(interface->name, true).c_str());
	    fprintf(out,"begin\n");
 	    fprintf(out,"  Result := %sImpl.is%sImpl(this);\n",escapeName(interface->name, true).c_str(),
 	                                                              escapeName(interface->name, true).c_str());
 	    fprintf(out,"end;\n\n");
 	    
		fprintf(out,"function T%s.as%sImpl: %sImpl;\n",  escapeName(interface->name).c_str(),
		                                                      escapeName(interface->name,true).c_str(),
		                                                      escapeName(interface->name,true).c_str());
	    fprintf(out,"begin\n");
 	    fprintf(out,"  if is%sImpl then\n",escapeName(interface->name, true).c_str());
 	    fprintf(out,"    Result := FObject as %sImpl\n",escapeName(interface->name, true).c_str());
 	    fprintf(out,"  else\n");
 	    fprintf(out,"    raise %s.CreateFmt(errNotImplementationObject,['%sImpl']);\n",exceptionClass.c_str(),escapeName(interface->name, true).c_str());
 	    fprintf(out,"end;\n\n");
 	    
		//Access methods for constants
		
		fprintf(out,"function T%s.VERSION: NativeInt;\n",escapeName(interface->name).c_str());
	    fprintf(out,"begin\n");
		fprintf(out,"  Result := %sImpl.VERSION;\n",escapeName(interface->name,true).c_str());
		fprintf(out,"end;\n\n");
		outputAllConstAccessFunctions(interface);

		//Now for each implementation method
		
  	    outputAllImplementationMethods(interface,escapeName(interface->name));
	}
		
	for (vector<Interface*>::iterator i = parser->interfaces.begin();
		 i != parser->interfaces.end();
		 ++i)
	{
		Interface* interface = *i;
		
		
		fprintf(out,"function %sImpl.as%s:%s;\n",escapeName(interface->name, true).c_str(),
		                                                      escapeName(interface->name, true).c_str(),
		                                                      escapeName(interface->name, true).c_str());
	    fprintf(out,"begin\n");
	    fprintf(out,"  Result := %s(@FNullPtr);\n",escapeName(interface->name, true).c_str());
 	    fprintf(out,"end;\n\n");

        outputAllDispatcherMethods(interface);
        
		//vtable declaration
		fprintf(out,"var %sImpl_vTable: %sVTable = (\n", escapeName(interface->name,true).c_str(),escapeName(interface->name).c_str());
		fprintf(out,"     NullPtr: nil;\n");
		
		//count methods
		deque<Method*> methods;
		for (Interface* p = interface; p; p = p->super)
			methods.insert(methods.begin(), p->methods.begin(), p->methods.end());
		fprintf(out,"     version: %d", (int) methods.size());
		
		outputAllvTableInitialisers(interface);
		
		fprintf(out,");\n\n");
		
		//now output the methods that depend on the vTable
		
		fprintf(out, "constructor %sImpl.create;\n", escapeName(interface->name, true).c_str());
		fprintf(out, "begin\n");
		fprintf(out, "  inherited Create;\n");
		if (!interface->super)
		  fprintf(out, "  FObject := self;\n");
		fprintf(out, "  FvTable := @%sImpl_vTable;\n",escapeName(interface->name, true).c_str());
		fprintf(out, "end;\n\n");
		 	    
		fprintf(out,"function %sImpl.getVTable: P%sVTable;\n", escapeName(interface->name, true).c_str(),escapeName(interface->name).c_str());
		fprintf(out, "begin\n");
		fprintf(out,"  Result := P%sVTable(FvTable);\n", escapeName(interface->name).c_str());
		fprintf(out, "end;\n\n");
		
		fprintf(out,"class function %sImpl.is%sImpl(intf: %s): boolean;\n",escapeName(interface->name, true).c_str(),
		                                                                escapeName(interface->name, true).c_str(),
		                                                                escapeName(interface->name, true).c_str());		
		fprintf(out,"begin\n");
		fprintf(out,"  Result := (intf.vTable = @%sImpl_vTable)", escapeName(interface->name, true).c_str());

		//Add a test for each subclass
	    for (vector<Interface*>::iterator i = parser->interfaces.begin();
		   i != parser->interfaces.end();
		   ++i)
		{
			Interface* subclass = *i;
			if (subclass->super == interface)
			  fprintf(out," or\n    %sImpl.is%sImpl(%s(intf))",escapeName(subclass->name, true).c_str(),
		                                                                escapeName(subclass->name, true).c_str(),
		                                                                escapeName(subclass->name, true).c_str());		
		}
		fprintf(out,";\n");
		fprintf(out,"end;\n\n");
	}
	
	insertFile(implementationFile);

	fprintf(out, "\n");

	fprintf(out, "end.\n");
}

void PascalGenerator::outputAllVTableMethods(Interface* interface)
{
	if (interface->super)
	  outputAllVTableMethods(interface->super);
	  
	for (vector<Method*>::iterator j = interface->methods.begin();
			 j != interface->methods.end();
			 ++j)
	{
		Method* method = *j;

		fprintf(out, "\t  %s: %s_%sPtr;\n", escapeName(method->name).c_str(),
				escapeName(interface->name, true).c_str(), escapeName(method->name).c_str());
	}
}

void PascalGenerator::outputAllConstants(Interface* interface)
{
	
	for (vector<Constant*>::iterator j = interface->constants.begin();
	 j != interface->constants.end();
		 ++j)
	{
		Constant* constant = *j;

		fprintf(out, "\t  const %s = %s(%s);\n",
				constant->name.c_str(),
				convertType(constant->typeRef).c_str(),
				constant->expr->generate(LANGUAGE_PASCAL, prefix).c_str());
	}
}

void PascalGenerator::outputAllConstInlineFunctionDeclarations(Interface* interface)
{
	if (interface->super)
	  outputAllConstInlineFunctionDeclarations(interface->super);
	  
	for (vector<Constant*>::iterator j = interface->constants.begin();
	        j != interface->constants.end(); ++j)
    {
			
		       Constant* constant = *j;
		       fprintf(out,"\t  function %s: %s; inline;\n",constant->name.c_str(),
				         convertType(constant->typeRef).c_str());
	}
}

void PascalGenerator::outputAllConstAccessFunctions(Interface* interface, std::string interfaceName)
{
	if (interfaceName.empty())
	  interfaceName = interface->name;
	  
	if (interface->super)
	  outputAllConstAccessFunctions(interface->super, interfaceName);
	  

  	for (vector<Constant*>::iterator j = interface->constants.begin();
	          j != interface->constants.end(); ++j)
	{
			
		       Constant* constant = *j;
		       fprintf(out,"function T%s.%s: %s;\n",escapeName(interfaceName).c_str(),constant->name.c_str(),
				                                       convertType(constant->typeRef).c_str());
			   fprintf(out,"begin\n");
			   fprintf(out,"  Result := %sImpl.%s;\n",escapeName(interface->name,true).c_str(),constant->name.c_str());
			   fprintf(out,"end;\n\n");
    }
}


void PascalGenerator::outputAllMethods(Interface* interface)
{
	if (interface->super)
	  outputAllMethods(interface->super);

	for (vector<Method*>::iterator j = interface->methods.begin();
			 j != interface->methods.end();
			 ++j)
	{
			Method* method = *j;

			bool isProcedure = method->returnTypeRef.token.type == Token::TYPE_VOID &&
				 !method->returnTypeRef.isPointer;

			fprintf(out, "\t  %s %s(",
				(isProcedure ? "procedure" : "function"),
				escapeName(method->name).c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				if (k != method->parameters.begin())
					fprintf(out, "; ");

				fprintf(out, "%s", convertParameter(*parameter).c_str());
			}

			fprintf(out, ")");

			if (!isProcedure)
				fprintf(out, ": %s", convertType(method->returnTypeRef).c_str());

			fprintf(out, ";\n");
	}
}

void PascalGenerator::outputAllImplementationMethods(Interface* interface, std::string interfaceName)
{
	if (interface->super)
	  outputAllImplementationMethods(interface->super,interfaceName);
	  
	for (vector<Method*>::iterator j = interface->methods.begin();
			 j != interface->methods.end();
			 ++j)
	{
			Method* method = *j;

			bool isProcedure = method->returnTypeRef.token.type == Token::TYPE_VOID &&
				 !method->returnTypeRef.isPointer;

			fprintf(out, "%s T%s.%s(",
				(isProcedure ? "procedure" : "function"),
				interfaceName.c_str(),
				escapeName(method->name).c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				if (k != method->parameters.begin())
					fprintf(out, "; ");

				fprintf(out, "%s", convertParameter(*parameter).c_str());
			}

			fprintf(out, ")");

			if (!isProcedure)
				fprintf(out, ": %s", convertType(method->returnTypeRef).c_str());

			fprintf(out, ";\n");
			fprintf(out, "begin\n");
			fprintf(out, "\t");

			//// TODO: checkVersion

			if (!isProcedure)
				fprintf(out, "Result := ");

			if (interfaceName == interface->name)
		      fprintf(out, "vTable^.%s(this", escapeName(method->name).c_str());
		    else
		      fprintf(out, "vTable^.%s(%s(this)", escapeName(method->name).c_str(),
		                                                           escapeName(interface->name,true).c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;
				fprintf(out, ", %s", escapeName(parameter->name).c_str());
			}

			fprintf(out, ");\n");

			if (!method->parameters.empty() &&
				parser->exceptionInterface &&
				method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name &&
				!exceptionClass.empty())
			{
				fprintf(out, "\t{$IFDEF USEFBEXCEPTION}%s.checkException(%s);{$ENDIF}\n", exceptionClass.c_str(),
					escapeName(method->parameters.front()->name).c_str());
			}

			fprintf(out, "end;\n\n");
	}
}

void PascalGenerator::outputAllDispatcherMethods(Interface* interface)
{
		deque<Method*> methods;

		for (Interface* p = interface; p; p = p->super)
			methods.insert(methods.begin(), p->methods.begin(), p->methods.end());

		for (deque<Method*>::iterator j = methods.begin(); j != methods.end(); ++j)
		{
			Method* method = *j;

			bool isProcedure = method->returnTypeRef.token.type == Token::TYPE_VOID &&
				 !method->returnTypeRef.isPointer;

			fprintf(out, "%s %sImpl_%sDispatcher(this: %s",
				(isProcedure ? "procedure" : "function"),
				escapeName(interface->name, true).c_str(),
				escapeName(method->name).c_str(),
				escapeName(interface->name,true).c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				fprintf(out, "; %s", convertParameter(*parameter).c_str());
			}

			fprintf(out, ")");

			if (!isProcedure)
				fprintf(out, ": %s", convertType(method->returnTypeRef).c_str());

			fprintf(out, "; cdecl;\n");
			fprintf(out, "begin\n");

			if (!exceptionClass.empty())
				fprintf(out, "\ttry\n\t");

			fprintf(out, "\t");

			if (!isProcedure)
				fprintf(out, "Result := ");
			fprintf(out,"this.as%sImpl.%s(",escapeName(interface->name,true).c_str(),
			                               escapeName(method->name).c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				if (k != method->parameters.begin())
					fprintf(out, ", ");

				fprintf(out, "%s", escapeName(parameter->name).c_str());
			}

			fprintf(out, ");\n");

			if (!exceptionClass.empty())
			{
				Parameter* exceptionParameter =
					(!method->parameters.empty() &&
					 parser->exceptionInterface &&
					 method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name
					) ? method->parameters.front() : NULL;

				fprintf(out, "\texcept\n");
				fprintf(out, "\t\ton e: Exception do %s.catchException(%s, e);\n",
					exceptionClass.c_str(),
					(exceptionParameter ? escapeName(exceptionParameter->name).c_str() : "nil"));

				fprintf(out, "\tend\n");
			}

			fprintf(out, "end;\n\n");
	}
}	

void PascalGenerator::outputAllvTableInitialisers(Interface* interface)
{
		
	if (interface->super)
	  outputAllvTableInitialisers(interface->super);
	  
	for (vector<Method*>::iterator j = interface->methods.begin();
			 j != interface->methods.end();
			 ++j)
	{
			Method* method = *j;
			fprintf(out,";\n     %s: %sImpl_%sDispatcher",escapeName(method->name).c_str(),
			                                          escapeName(interface->name, true).c_str(),
			                                          escapeName(method->name).c_str());
	}
}


std::string PascalGenerator::convertParameter(const Parameter& parameter)
{
	return escapeName(parameter.name) + ": " + convertType(parameter.typeRef);
}


string PascalGenerator::convertType(const TypeRef& typeRef)
{
	string name;
	
	if (isInterfaceName(typeRef.token.text)) 
		  name = escapeName(typeRef.token.text,true);
	else
	{
	  switch (typeRef.token.type)
	  {
		case Token::TYPE_BOOLEAN:
			name = "Boolean";
			break;

		case Token::TYPE_INT:
			name = "Integer";
			break;

		case Token::TYPE_INT64:
			name = "Int64";
			break;

		case Token::TYPE_INTPTR:
			name = "NativeInt";
			break;

		case Token::TYPE_STRING:
			name = "PAnsiChar";
			break;

		case Token::TYPE_UCHAR:
			name = "Byte";
			break;

		case Token::TYPE_UINT:
			name = "Cardinal";
			break;

		case Token::TYPE_UINT64:
			name = "QWord";
			break;
			
		case Token::TYPE_IDENTIFIER:
			name = (typeRef.type == BaseType::TYPE_INTERFACE ? prefix : "") + typeRef.token.text;
			break;

		default:
			name = typeRef.token.text;
			break;
	  }

	  if (typeRef.isPointer)
	  {
		if (name == "void")
			return "Pointer";

		if (pointerTypes.find(name) == pointerTypes.end())
			pointerTypes.insert(name);

		name += "Ptr";
	  }
	}

	return name;
}

bool PascalGenerator::isInterfaceName(std::string name)
{
	for (vector<Interface*>::iterator i = parser->interfaces.begin();
		 i != parser->interfaces.end();
		 ++i)
	{
		Interface* interface = *i;
		if (interface->name == name)
		  return true;
	}
	return false;
}

string PascalGenerator::escapeName(string name, bool interfaceName)
{
	//// TODO: Create a table of keywords.

	if (name == "file" ||
		name == "function" ||
		name == "procedure" ||
		name == "set" ||
		name == "to" ||
		name == "type" ||
		name == "record")
	{
		name += "_";
	}

	if (interfaceName)
		name = prefix + name;

	return name;
}

void PascalGenerator::insertFile(const string& filename)
{
	if (filename.empty())
		return;

	FILE* in = fopen(filename.c_str(), "r");

	if (!in)
		throw runtime_error(string("Error opening input file '") + filename + "'.");

	char buffer[1024];
	int count;

	while ((count = fread(buffer, 1, sizeof(buffer), in)) > 0)
		fwrite(buffer, 1, count, out);

	fclose(in);
}


//--------------------------------------


JnaGenerator::JnaGenerator(const string& filename, const string& prefix, Parser* parser,
		const string& className, const string& exceptionClass)
	: FileGenerator(filename, prefix),
	  parser(parser),
	  className(className),
	  exceptionClass(exceptionClass)
{
}

void JnaGenerator::generate()
{
	fprintf(out, "// %s\n\n", AUTOGEN_MSG);

	string::size_type lastDot = className.rfind('.');
	string::size_type classStart;

	if (lastDot != string::npos)
	{
		fprintf(out, "package %s;\n", className.substr(0, lastDot).c_str());
		fprintf(out, "\n");
		fprintf(out, "\n");

		classStart = lastDot + 1;
	}
	else
		classStart = 0;

	fprintf(out, "public interface %s extends com.sun.jna.Library\n",
		className.substr(classStart).c_str());
	fprintf(out, "{\n");

	for (vector<Interface*>::iterator i = parser->interfaces.begin();
		 i != parser->interfaces.end();
		 ++i)
	{
		if (i != parser->interfaces.begin())
			fprintf(out, "\n");

		Interface* interface = *i;

		fprintf(out, "\tpublic static interface %s%sIntf",
			prefix.c_str(), escapeName(interface->name).c_str());

		if (interface->super)
		{
			fprintf(out, " extends %s%sIntf",
				prefix.c_str(), escapeName(interface->super->name).c_str());
		}

		fprintf(out, "\n");
		fprintf(out, "\t{\n");

		//// TODO: version

		for (vector<Constant*>::iterator j = interface->constants.begin();
			 j != interface->constants.end();
			 ++j)
		{
			Constant* constant = *j;

			fprintf(out, "\t\tpublic static %s %s = %s;\n",
				convertType(constant->typeRef, false).c_str(),
				constant->name.c_str(),
				constant->expr->generate(LANGUAGE_JAVA, prefix).c_str());
		}

		if (!interface->constants.empty())
			fprintf(out, "\n");


		for (vector<Method*>::iterator j = interface->methods.begin();
			 j != interface->methods.end();
			 ++j)
		{
			Method* method = *j;

			fprintf(out, "\t\tpublic %s %s(",
				convertType(method->returnTypeRef, true).c_str(),
				escapeName(method->name).c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				if (k != method->parameters.begin())
					fprintf(out, ", ");

				fprintf(out, "%s %s",
					convertType(parameter->typeRef, false).c_str(),
					escapeName(parameter->name).c_str());
			}

			bool mayThrow = !method->parameters.empty() &&
				parser->exceptionInterface &&
				method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name &&
				!exceptionClass.empty();

			fprintf(out, ")");

			if (mayThrow)
				fprintf(out, " throws %s", exceptionClass.c_str());

			fprintf(out, ";\n");
		}

		fprintf(out, "\t}\n");
	}

	for (vector<Interface*>::iterator i = parser->interfaces.begin();
		 i != parser->interfaces.end();
		 ++i)
	{
		Interface* interface = *i;

		fprintf(out, "\n");
		fprintf(out, "\tpublic static class %s%s extends ",
			prefix.c_str(), escapeName(interface->name).c_str());

		if (interface->super)
			fprintf(out, "%s%s", prefix.c_str(), escapeName(interface->super->name).c_str());
		else
			fprintf(out, "com.sun.jna.Structure");

		fprintf(out, " implements %s%sIntf\n", prefix.c_str(), escapeName(interface->name).c_str());
		fprintf(out, "\t{\n");

		fprintf(out, "\t\tpublic static class VTable extends ");

		if (interface->super)
			fprintf(out, "%s%s.VTable", prefix.c_str(), escapeName(interface->super->name).c_str());
		else
			fprintf(out, "com.sun.jna.Structure implements com.sun.jna.Structure.ByReference");

		fprintf(out, "\n");
		fprintf(out, "\t\t{\n");

		for (vector<Method*>::iterator j = interface->methods.begin();
			 j != interface->methods.end();
			 ++j)
		{
			Method* method = *j;

			fprintf(out, "\t\t\tpublic static interface Callback_%s extends com.sun.jna.Callback\n",
				escapeName(method->name).c_str());
			fprintf(out, "\t\t\t{\n");
			fprintf(out, "\t\t\t\tpublic %s invoke(%s%s self",
				convertType(method->returnTypeRef, true).c_str(),
				prefix.c_str(),
				escapeName(interface->name).c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				fprintf(out, ", %s %s",
					convertType(parameter->typeRef, false).c_str(),
					escapeName(parameter->name).c_str());
			}

			fprintf(out, ");\n");
			fprintf(out, "\t\t\t}\n");
			fprintf(out, "\n");
		}

		if (!interface->super)
		{
			fprintf(out, "\t\t\tpublic com.sun.jna.Pointer cloopDummy;\n");
			fprintf(out, "\t\t\tpublic com.sun.jna.Pointer version;\n");
			fprintf(out, "\n");
		}

		fprintf(out, "\t\t\tpublic VTable(com.sun.jna.Pointer pointer)\n");
		fprintf(out, "\t\t\t{\n");
		fprintf(out, "\t\t\t\tsuper(pointer);\n");
		fprintf(out, "\t\t\t}\n");
		fprintf(out, "\n");

		fprintf(out, "\t\t\tpublic VTable(%s%sIntf obj)\n",
			prefix.c_str(), escapeName(interface->name).c_str());
		fprintf(out, "\t\t\t{\n");

		if (interface->super)
		{
			fprintf(out, "\t\t\t\tsuper(obj);\n");
			fprintf(out, "\n");
		}

		for (vector<Method*>::iterator j = interface->methods.begin();
			 j != interface->methods.end();
			 ++j)
		{
			Method* method = *j;

			fprintf(out, "\t\t\t\t%s = new Callback_%s() {\n",
				escapeName(method->name).c_str(), escapeName(method->name).c_str());
			fprintf(out, "\t\t\t\t\t@Override\n");
			fprintf(out, "\t\t\t\t\tpublic %s invoke(%s%s self",
				convertType(method->returnTypeRef, true).c_str(),
				prefix.c_str(),
				escapeName(interface->name).c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				fprintf(out, ", %s %s",
					convertType(parameter->typeRef, false).c_str(),
					escapeName(parameter->name).c_str());
			}

			string statusName;

			if (!method->parameters.empty() &&
				parser->exceptionInterface &&
				method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name)
			{
				statusName = method->parameters.front()->name;
			}

			fprintf(out, ")\n");
			fprintf(out, "\t\t\t\t\t{\n");
			fprintf(out, "\t\t\t\t\t\t");

			if (!statusName.empty())
			{
				fprintf(out, "try\n");
				fprintf(out, "\t\t\t\t\t\t{\n");
				fprintf(out, "\t\t\t\t\t\t\t");
			}

			if (method->returnTypeRef.token.type != Token::TYPE_VOID ||
				method->returnTypeRef.isPointer)
			{
				fprintf(out, "return ");
			}

			fprintf(out, "obj.%s(", escapeName(method->name).c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				if (k != method->parameters.begin())
					fprintf(out, ", ");

				fprintf(out, "%s", escapeName(parameter->name).c_str());
			}

			fprintf(out, ");\n");

			if (!statusName.empty())
			{
				fprintf(out, "\t\t\t\t\t\t}\n");
				fprintf(out, "\t\t\t\t\t\tcatch (Throwable t)\n");
				fprintf(out, "\t\t\t\t\t\t{\n");
				fprintf(out, "\t\t\t\t\t\t\t%s.catchException(%s, t);\n",
					exceptionClass.c_str(), statusName.c_str());

				if (method->returnTypeRef.token.type != Token::TYPE_VOID ||
					method->returnTypeRef.isPointer)
				{
					fprintf(out, "\t\t\t\t\t\t\treturn %s;\n",
						literalForError(method->returnTypeRef).c_str());
				}

				fprintf(out, "\t\t\t\t\t\t}\n");
			}

			fprintf(out, "\t\t\t\t\t}\n");
			fprintf(out, "\t\t\t\t};\n");

			if (j + 1 != interface->methods.end())
				fprintf(out, "\n");
		}

		fprintf(out, "\t\t\t}\n");
		fprintf(out, "\n");

		fprintf(out, "\t\t\tpublic VTable()\n");
		fprintf(out, "\t\t\t{\n");
		fprintf(out, "\t\t\t}\n");
		fprintf(out, "\n");

		for (vector<Method*>::iterator j = interface->methods.begin();
			 j != interface->methods.end();
			 ++j)
		{
			Method* method = *j;

			fprintf(out, "\t\t\tpublic Callback_%s %s;\n",
				escapeName(method->name).c_str(),
				escapeName(method->name).c_str());
		}

		if (!interface->methods.empty())
			fprintf(out, "\n");

		fprintf(out, "\t\t\t@Override\n");
		fprintf(out, "\t\t\tprotected java.util.List<String> getFieldOrder()\n");
		fprintf(out, "\t\t\t{\n");

		if (interface->super)
			fprintf(out, "\t\t\t\tjava.util.List<String> fields = super.getFieldOrder();\n");
		else
			fprintf(out, "\t\t\t\tjava.util.List<String> fields = new java.util.ArrayList<String>();\n");

		if (!interface->super || interface->methods.size() != 0)
		{
			fprintf(out, "\t\t\t\tfields.addAll(java.util.Arrays.asList(");

			if (!interface->super)
				fprintf(out, "\"cloopDummy\", \"version\"");

			bool first = interface->super != NULL;

			for (vector<Method*>::iterator j = interface->methods.begin();
				 j != interface->methods.end();
				 ++j)
			{
				Method* method = *j;

				if (first)
					first = false;
				else
					fprintf(out, ", ");

				fprintf(out, "\"%s\"", escapeName(method->name).c_str());
			}

			fprintf(out, "));\n");
		}

		fprintf(out, "\t\t\t\treturn fields;\n");
		fprintf(out, "\t\t\t}\n");
		fprintf(out, "\t\t}\n");

		if (!interface->super)
		{
			fprintf(out, "\n");
			fprintf(out, "\t\tpublic com.sun.jna.Pointer cloopDummy;\n");
			fprintf(out, "\t\tpublic com.sun.jna.Pointer cloopVTable;\n");
			fprintf(out, "\t\tprotected volatile VTable vTable;\n");
			fprintf(out, "\n");
			fprintf(out, "\t\t@Override\n");
			fprintf(out, "\t\tprotected java.util.List<String> getFieldOrder()\n");
			fprintf(out, "\t\t{\n");
			fprintf(out, "\t\t\tjava.util.List<String> fields = new java.util.ArrayList<String>();\n");
			fprintf(out, "\t\t\tfields.addAll(java.util.Arrays.asList(\"cloopDummy\", \"cloopVTable\"));\n");
			fprintf(out, "\t\t\treturn fields;\n");
			fprintf(out, "\t\t}\n");
			fprintf(out, "\n");
			fprintf(out, "\t\t@SuppressWarnings(\"unchecked\")\n");
			fprintf(out, "\t\tpublic final <T extends VTable> T getVTable()\n");
			fprintf(out, "\t\t{\n");
			fprintf(out, "\t\t\tif (vTable == null)\n");
			fprintf(out, "\t\t\t{\n");
			fprintf(out, "\t\t\t\tsynchronized (cloopVTable)\n");
			fprintf(out, "\t\t\t\t{\n");
			fprintf(out, "\t\t\t\t\tif (vTable == null)\n");
			fprintf(out, "\t\t\t\t\t{\n");
			fprintf(out, "\t\t\t\t\t\tvTable = createVTable();\n");
			fprintf(out, "\t\t\t\t\t\tvTable.read();\n");
			fprintf(out, "\t\t\t\t\t}\n");
			fprintf(out, "\t\t\t\t}\n");
			fprintf(out, "\t\t\t}\n");
			fprintf(out, "\n");
			fprintf(out, "\t\t\treturn (T) vTable;\n");
			fprintf(out, "\t\t}\n");
		}

		fprintf(out, "\n");

		fprintf(out, "\t\tpublic %s%s()\n", prefix.c_str(), escapeName(interface->name).c_str());
		fprintf(out, "\t\t{\n");
		fprintf(out, "\t\t}\n");
		fprintf(out, "\n");

		fprintf(out, "\t\tpublic %s%s(%s%sIntf obj)\n",
			prefix.c_str(), escapeName(interface->name).c_str(),
			prefix.c_str(), escapeName(interface->name).c_str());
		fprintf(out, "\t\t{\n");
		fprintf(out, "\t\t\tvTable = new VTable(obj);\n");
		fprintf(out, "\t\t\tvTable.write();\n");
		fprintf(out, "\t\t\tcloopVTable = vTable.getPointer();\n");
		fprintf(out, "\t\t\twrite();\n");
		fprintf(out, "\t\t}\n");
		fprintf(out, "\n");

		if (interface->super)
			fprintf(out, "\t\t@Override\n");

		fprintf(out, "\t\tprotected VTable createVTable()\n");
		fprintf(out, "\t\t{\n");
		fprintf(out, "\t\t\treturn new VTable(cloopVTable);\n");
		fprintf(out, "\t\t}\n");

		for (vector<Method*>::iterator j = interface->methods.begin();
			 j != interface->methods.end();
			 ++j)
		{
			Method* method = *j;

			fprintf(out, "\n");
			fprintf(out, "\t\tpublic %s %s(",
				convertType(method->returnTypeRef, true).c_str(),
				escapeName(method->name).c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				if (k != method->parameters.begin())
					fprintf(out, ", ");

				fprintf(out, "%s %s",
					convertType(parameter->typeRef, false).c_str(),
					escapeName(parameter->name).c_str());
			}

			bool mayThrow = !method->parameters.empty() &&
				parser->exceptionInterface &&
				method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name &&
				!exceptionClass.empty();

			fprintf(out, ")");

			if (mayThrow)
				fprintf(out, " throws %s", exceptionClass.c_str());

			fprintf(out, "\n");
			fprintf(out, "\t\t{\n");
			fprintf(out, "\t\t\tVTable vTable = getVTable();\n");

			fprintf(out, "\t\t\t");

			if (method->returnTypeRef.token.type != Token::TYPE_VOID ||
				method->returnTypeRef.isPointer)
			{
				fprintf(out, "%s result = ", convertType(method->returnTypeRef, true).c_str());
			}

			fprintf(out, "vTable.%s.invoke(this", escapeName(method->name).c_str());

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;
				fprintf(out, ", %s", escapeName(parameter->name).c_str());
			}

			fprintf(out, ");");
			fprintf(out, "\n");

			if (!method->parameters.empty() &&
				parser->exceptionInterface &&
				method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name &&
				!exceptionClass.empty())
			{
				fprintf(out, "\t\t\t%s.checkException(%s);\n", exceptionClass.c_str(),
					escapeName(method->parameters.front()->name).c_str());
			}

			if (method->returnTypeRef.token.type != Token::TYPE_VOID ||
				method->returnTypeRef.isPointer)
			{
				fprintf(out, "\t\t\treturn result;\n");
			}

			fprintf(out, "\t\t}\n");
		}

		fprintf(out, "\t}\n");
	}

	fprintf(out, "}\n");
}

string JnaGenerator::convertType(const TypeRef& typeRef, bool forReturn)
{
	string name;

	switch (typeRef.token.type)
	{
		case Token::TYPE_BOOLEAN:
			name = "boolean";
			break;

		case Token::TYPE_INT:
			name = "int";
			break;

		case Token::TYPE_INT64:
			name = "long";
			break;

		case Token::TYPE_INTPTR:
			name = "com.sun.jna.Pointer";
			break;

		case Token::TYPE_STRING:
			if (typeRef.isConst)
				name = "String";
			else
				name = "com.sun.jna.Pointer";
			break;

		case Token::TYPE_UCHAR:
			name = "byte";
			break;

		case Token::TYPE_UINT:
			name = "int";
			break;

		case Token::TYPE_UINT64:
			name = "long";
			break;

		default:
			if (typeRef.type == BaseType::TYPE_INTERFACE &&
				typeRef.token.type == Token::TYPE_IDENTIFIER)
			{
				name = prefix;
			}

			name += typeRef.token.text;
			break;
	}

	if (typeRef.isPointer)
	{
		if (forReturn || name == "void")
			return "com.sun.jna.Pointer";
		else
			name += "[]";
	}

	return name;
}

string JnaGenerator::literalForError(const TypeRef& typeRef)
{
	if (typeRef.isPointer)
		return "null";

	switch (typeRef.token.type)
	{
		case Token::TYPE_BOOLEAN:
			return "false";

		case Token::TYPE_INT:
		case Token::TYPE_INT64:
		case Token::TYPE_UINT:
		case Token::TYPE_UINT64:
			return "0";

		case Token::TYPE_UCHAR:
			return "(byte) 0";

		default:
			return "null";
	}
}

string JnaGenerator::escapeName(const string& name)
{
	//// TODO: Create a table of keywords.
	return name;
}


//--------------------------------------


JsonGenerator::JsonGenerator(const string& filename, Parser* parser)
	: FileGenerator(filename, ""),
	  parser(parser)
{
}

void JsonGenerator::generate()
{
	fprintf(out, "{\n");
	fprintf(out, "\t\"library\":\n");
	fprintf(out, "\t{\n");

	fprintf(out, "\t\t\"interfaces\":\n");
	fprintf(out, "\t\t[\n");

	for (vector<Interface*>::iterator i = parser->interfaces.begin();
		 i != parser->interfaces.end();
		 ++i)
	{
		Interface* interface = *i;

		fprintf(out, "\t\t\t{\n");
		fprintf(out, "\t\t\t\t\"name\": \"%s\",\n", interface->name.c_str());
		fprintf(out, "\t\t\t\t\"version\": %d,\n", interface->version);

		if (interface->super)
			fprintf(out, "\t\t\t\t\"extends\": \"%s\",\n", interface->super->name.c_str());

		fprintf(out, "\t\t\t\t\"constants\":\n");
		fprintf(out, "\t\t\t\t[\n");

		for (vector<Constant*>::iterator j = interface->constants.begin();
			 j != interface->constants.end();
			 ++j)
		{
			Constant* constant = *j;

			fprintf(out, "\t\t\t\t\t{\n");
			fprintf(out, "\t\t\t\t\t\t\"name\": \"%s\",\n", constant->name.c_str());
			fprintf(out, "\t\t\t\t\t\t\"type\": %s,\n", convertType(constant->typeRef).c_str());
			fprintf(out, "\t\t\t\t\t\t\"expr\": %s\n",
				constant->expr->generate(LANGUAGE_JSON, prefix).c_str());

			fprintf(out, "\t\t\t\t\t}");

			if (j + 1 != interface->constants.end())
				fprintf(out, ",");

			fprintf(out, "\n");
		}

		fprintf(out, "\t\t\t\t],\n");

		fprintf(out, "\t\t\t\t\"methods\":\n");
		fprintf(out, "\t\t\t\t[\n");

		for (vector<Method*>::iterator j = interface->methods.begin();
			 j != interface->methods.end();
			 ++j)
		{
			Method* method = *j;

			fprintf(out, "\t\t\t\t\t{\n");
			fprintf(out, "\t\t\t\t\t\t\"name\": \"%s\",\n", method->name.c_str());
			fprintf(out, "\t\t\t\t\t\t\"version\": %d,\n", method->version);
			fprintf(out, "\t\t\t\t\t\t\"returnType\": %s,\n",
				convertType(method->returnTypeRef).c_str());

			bool mayThrow = !method->parameters.empty() &&
				parser->exceptionInterface &&
				method->parameters.front()->typeRef.token.text == parser->exceptionInterface->name;

			fprintf(out, "\t\t\t\t\t\t\"mayThrow\": %s,\n", (mayThrow ? "true" : "false"));

			if (method->notImplementedExpr)
			{
				fprintf(out, "\t\t\t\t\t\t\"notImplementedExpr\": %s,\n",
					method->notImplementedExpr->generate(LANGUAGE_JSON, prefix).c_str());
			}

			fprintf(out, "\t\t\t\t\t\t\"parameters\":\n");
			fprintf(out, "\t\t\t\t\t\t[\n");

			for (vector<Parameter*>::iterator k = method->parameters.begin();
				 k != method->parameters.end();
				 ++k)
			{
				Parameter* parameter = *k;

				fprintf(out, "\t\t\t\t\t\t\t{\n");
				fprintf(out, "\t\t\t\t\t\t\t\t\"name\": \"%s\",\n", parameter->name.c_str());
				fprintf(out, "\t\t\t\t\t\t\t\t\"type\": %s\n",
					convertType(parameter->typeRef).c_str());
				fprintf(out, "\t\t\t\t\t\t\t}");

				if (k + 1 != method->parameters.end())
					fprintf(out, ", ");

				fprintf(out, "\n");
			}

			fprintf(out, "\t\t\t\t\t\t]\n");
			fprintf(out, "\t\t\t\t\t}");

			if (j + 1 != interface->methods.end())
				fprintf(out, ",");

			fprintf(out, "\n");
		}

		fprintf(out, "\t\t\t\t]\n");

		fprintf(out, "\t\t\t}");

		if (i + 1 != parser->interfaces.end())
			fprintf(out, ",");

		fprintf(out, "\n");
	}

	fprintf(out, "\t\t]\n");
	fprintf(out, "\t}\n");
	fprintf(out, "}\n");
}

string JsonGenerator::convertType(const TypeRef& typeRef)
{
	return "{ \"name\": \"" + typeRef.token.text +
		"\", \"isPointer\": " + (typeRef.isPointer ? "true" : "false") +
		", \"isConst\": " + (typeRef.isConst ? "true" : "false") +
		" }";
}
